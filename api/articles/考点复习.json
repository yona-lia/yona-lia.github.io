{"title":"考点复习","uid":"cf3e005cfd96f68780fbdebaaab6e37f","slug":"考点复习","date":"2025-06-10T16:13:46.000Z","updated":"2025-06-10T17:00:05.699Z","comments":true,"path":"api/articles/考点复习.json","keywords":null,"cover":[],"content":"<h1 id=\"考点复习\"><a href=\"#考点复习\" class=\"headerlink\" title=\"考点复习\"></a>考点复习</h1><h1 id=\"一二\"><a href=\"#一二\" class=\"headerlink\" title=\"一二\"></a>一二</h1><h2 id=\"图形和图像的区别（选择）\"><a href=\"#图形和图像的区别（选择）\" class=\"headerlink\" title=\"图形和图像的区别（选择）\"></a>图形和图像的区别（选择）</h2><p>图形：矢量图，以几何数学为基础，由点、线、圆等图元组成，仅记录点的坐标数据及绘图命令</p>\n<p>图像：点阵图，用像素来描述的图，记录每个像素的位置和灰度</p>\n<h2 id=\"数字图像处理常用的输入输出设备\"><a href=\"#数字图像处理常用的输入输出设备\" class=\"headerlink\" title=\"数字图像处理常用的输入输出设备\"></a>数字图像处理常用的输入输出设备</h2><p><strong>触摸屏既是输入设备也是输出设备</strong></p>\n<p>输入设备：键盘，鼠标，图形输入板，数码相机，扫描仪，光密度仪等</p>\n<p>输出设备：显示器，打印机，图像拷贝机和绘图仪等</p>\n<h2 id=\"色彩模型\"><a href=\"#色彩模型\" class=\"headerlink\" title=\"色彩模型\"></a>色彩模型</h2><h3 id=\"RGB配比\"><a href=\"#RGB配比\" class=\"headerlink\" title=\"RGB配比\"></a>RGB配比</h3><p>整数：红（255,0,0）绿（0,255,0）蓝（0,0,255）白（255,255,255）黑（0,0,0）品红（红+蓝）（255,0,255）青（绿+蓝）（0,255,255）黄（红+绿）（255,255,0）</p>\n<p>归一化：红（1,0,0）绿（0,1,0）蓝（0,0,1）白（1,1,1）黑（0,0,0）品红（红+蓝）（1,0,1）青（绿+蓝）（0,1,1）黄（红+绿）（1,1,0）</p>\n<h3 id=\"HSI模型\"><a href=\"#HSI模型\" class=\"headerlink\" title=\"HSI模型\"></a>HSI模型</h3><p>H：色度（色度由角度表示，表示最接近什么基本色）</p>\n<p><strong>0°是红色，120°是绿色，240°是蓝色</strong></p>\n<p>S：饱和度（色环的圆心到某彩色点的半径长度，外围圆周饱和度为1，圆心饱和度为0）</p>\n<p>I：亮度（光照强度，确定像素的整体亮度）</p>\n<h3 id=\"黑白二值模型\"><a href=\"#黑白二值模型\" class=\"headerlink\" title=\"黑白二值模型\"></a>黑白二值模型</h3><p>二值模型：只有黑白两种颜色，其中黑是0，白是1。</p>\n<p>灰度模型：显示从白到黑的256个灰度级，黑色是0，白色是255.</p>\n<p>索引彩色：显示256种颜色</p>\n<p>真彩色：显示$2^{26}$种颜色</p>\n<h2 id=\"计算图像的存储空间\"><a href=\"#计算图像的存储空间\" class=\"headerlink\" title=\"计算图像的存储空间\"></a>计算图像的存储空间</h2><p>空间分辨率：$n*m$</p>\n<p>幅度分辨率：$2^k$</p>\n<p>占用空间：$m *n *k$（单位bit）</p>\n<h2 id=\"图像数字化\"><a href=\"#图像数字化\" class=\"headerlink\" title=\"图像数字化\"></a>图像数字化</h2><p>采样：空间离散化</p>\n<p>量化：灰度离散化</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><h2 id=\"点运算\"><a href=\"#点运算\" class=\"headerlink\" title=\"点运算\"></a>点运算</h2><p>$G&#x3D;aF+b$（F为输入的灰度值，G为输出的灰度值，a为斜率，b为截距）</p>\n<p>对比度：</p>\n<p>$a&gt;1,b&#x3D;0$：对比度增大</p>\n<p>$0&lt;a&lt;1,b&#x3D;0$：对比度减小</p>\n<p>灰度值：</p>\n<p>$a&#x3D;1,b&gt;0$：灰度值上移，亮度增加</p>\n<p>$a&#x3D;1,b&lt;0$：灰度值下移，亮度降低</p>\n<p>反相：</p>\n<p>$a&#x3D;-1,b&#x3D;255$</p>\n<h2 id=\"算术运算\"><a href=\"#算术运算\" class=\"headerlink\" title=\"算术运算\"></a>算术运算</h2><h3 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h3><p>$C(x,y)&#x3D;A(x,y)+B(x,y)$</p>\n<p><strong>主要应用：</strong></p>\n<p>去除“叠加性”噪音，生成图像叠加效果</p>\n<p>图像叠加方法：</p>\n<p>取均值：$g(x,y)&#x3D;f(x,y)&#x2F;2+h(x,y)&#x2F;2$</p>\n<p>推广：$g(x,y)&#x3D;af(x,y)+bh(x,y)（a+b&#x3D;1）$</p>\n<p>加法运算函数：$Z &#x3D; 0.5 * X + 0.5 * Y$（不可以合并写，会出问题）</p>\n<p><code>Z = imadd(X,Y);</code></p>\n<h3 id=\"减法\"><a href=\"#减法\" class=\"headerlink\" title=\"减法\"></a>减法</h3><p>$g(x,y) &#x3D; T_2(x,y) - T_1(x,y)$</p>\n<p>差值图像显示问题：$g(x,y)[-255,255]——-&gt;g(x,y)[0,255]$</p>\n<p>解决方法：</p>\n<p>方法一（线性平移和缩放）<br>$$<br>g(x,y)&#x3D;\\frac{g(x,y+255)}{2}<br>$$<br>方法二（归一化到动态范围）<br>$$<br>g(x,y)&#x3D;(g(x,y)-g_{min}(x,y)\\times \\frac{255}{g_{max}(x,y)-g_{min}(x,y)})<br>$$<br>减法运算函数：$Z&#x3D;X-Y$（要求X和Y大小一致，数组元素类型一致）</p>\n<p><code>Z=imsubtract(X,Y);</code></p>\n<h3 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h3><p>$C (x, y)＝A (x, y)*B (x, y)$</p>\n<p><strong>主要应用：</strong></p>\n<p>用二值图像与原图像做乘法（矩阵点乘），得到需要的子图像</p>\n<p>乘法运算函数：$Z&#x3D;X*Y$（X和Y做点乘，大小一致，数组元素类型一致）</p>\n<p><code>Z=immulyiply(X,Y);</code></p>\n<h3 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h3><p>$C (x, y) ＝A (x, y) &#x2F;B (x, y)$</p>\n<p><strong>主要应用：</strong></p>\n<p>用来改变图像的灰度级，校正成像设备的非线性影响</p>\n<p>除法运算函数：$Z&#x3D;X&#x2F;Y$（X和Y做点除，大小一致，数组元素类型一致）</p>\n<p><code>Z=imdivide(X,Y);</code></p>\n<h2 id=\"几何运算\"><a href=\"#几何运算\" class=\"headerlink\" title=\"几何运算\"></a>几何运算</h2><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><p>镜像种类：水平镜像，垂直镜像</p>\n<h4 id=\"水平镜像：\"><a href=\"#水平镜像：\" class=\"headerlink\" title=\"水平镜像：\"></a><strong>水平镜像：</strong></h4><p>$$<br>x_1 &#x3D; -x_0, \\quad y_1 &#x3D; y_0<br>$$</p>\n<h1 id=\"begin-bmatrix-x-1-y-1-1-end-bmatrix\"><a href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix\" class=\"headerlink\" title=\"$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\"></a>$$<br>\\begin{bmatrix}<br>x_1 \\<br>y_1 \\<br>1<br>\\end{bmatrix}</h1><p>\\begin{bmatrix}<br>-1 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>x_0 \\<br>y_0 \\<br>1<br>\\end{bmatrix}<br>$$</p>\n<p><strong>水平镜像时，由于矩阵下标不能为负，实际上要对图像矩阵左右翻转</strong></p>\n<p>水平镜像函数：<code>B = fliplr(A)</code>（将矩阵A左右翻转，实现水平镜像）</p>\n<h4 id=\"垂直镜像：\"><a href=\"#垂直镜像：\" class=\"headerlink\" title=\"垂直镜像：\"></a><strong>垂直镜像：</strong></h4><p>$$<br>x_1 &#x3D; x_0, \\quad y_1 &#x3D; -y_0<br>$$</p>\n<h1 id=\"begin-bmatrix-x-1-y-1-1-end-bmatrix-1\"><a href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-1\" class=\"headerlink\" title=\"$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\"></a>$$<br>\\begin{bmatrix}<br>x_1 \\<br>y_1 \\<br>1<br>\\end{bmatrix}</h1><p>\\begin{bmatrix}<br>1 &amp; 0 &amp; 0 \\<br>0 &amp; -1 &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>x_0 \\<br>y_0 \\<br>1<br>\\end{bmatrix}<br>$$</p>\n<p><strong>垂直镜像时，由于矩阵下标不能为负，实际上要对图像矩阵上下翻转</strong></p>\n<p>垂直镜像函数：<code>B = flipud(A)</code>（将矩阵A上下翻转，实现垂直镜像）</p>\n<h3 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h3><p>$$<br>x_1 &#x3D; x_0 + t_x,\\quad y_1 &#x3D; y_0 + t_y<br>$$</p>\n<h1 id=\"begin-bmatrix-x-1-y-1-1-end-bmatrix-2\"><a href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-2\" class=\"headerlink\" title=\"$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\"></a>$$<br>\\begin{bmatrix}<br>x_1 \\<br>y_1 \\<br>1<br>\\end{bmatrix}</h1><p>\\begin{bmatrix}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>x_0 \\<br>y_0 \\<br>1<br>\\end{bmatrix}<br>$$</p>\n<p>其中</p>\n<p>$A——tx&#x3D;2,ty&#x3D;1——-&gt;B$</p>\n<p>$B(2:3,3:3) &#x3D; A(1:2,1:1)$</p>\n<p>推广：$B(1+ty:M, 1+tx:N) &#x3D; A(1:M-ty,1:N-tx)$</p>\n<p>平移函数：<code>B = imtranslate(A,[tx,ty]);</code> （平移A，水平移动tx，垂直移动ty，可正可负）</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear all;</span><br><span class=\"line\">A= imread(<span class=\"string\">&#x27;bot.bmp&#x27;</span>);</span><br><span class=\"line\">imshow(A);</span><br><span class=\"line\">[M N]= <span class=\"built_in\">size</span>(A); B =<span class=\"built_in\">zeros</span>(M,N,class(A));</span><br><span class=\"line\">tx=<span class=\"number\">100</span>;ty=<span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span>=<span class=\"number\">1</span>:M</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">j</span>=<span class=\"number\">1</span>:N</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">i</span>-ty&gt;<span class=\"number\">0</span>) &amp;&amp;(<span class=\"built_in\">i</span>-ty&lt;M) &amp;&amp;(<span class=\"built_in\">j</span>-tr&gt;<span class=\"number\">0</span>) &amp;&amp;(<span class=\"built_in\">j</span>-tr&lt;N)</span><br><span class=\"line\">\t\t\tB(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=A(<span class=\"built_in\">i</span>-ty,<span class=\"built_in\">j</span>-tx);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tB(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>, imshow(B)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><p>$$<br>x_1 &#x3D; x_0 \\cos\\theta - y_0 \\sin\\theta \\<br>y_1 &#x3D; x_0 \\sin\\theta + y_0 \\cos\\theta<br>$$</p>\n<h1 id=\"begin-bmatrix-x-1-y-1-1-end-bmatrix-3\"><a href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-3\" class=\"headerlink\" title=\"$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\"></a>$$<br>\\begin{bmatrix}<br>x_1 \\<br>y_1 \\<br>1<br>\\end{bmatrix}</h1><p>\\begin{bmatrix}<br>\\cos\\theta &amp; -\\sin\\theta &amp; 0 \\<br>\\sin\\theta &amp; \\cos\\theta &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>x_0 \\<br>y_0 \\<br>1<br>\\end{bmatrix}<br>$$</p>\n<p><strong>注意：旋转后会出现很多空洞点，需要差值处理</strong></p>\n<p>差值处理方法：最邻近差值（近邻取样法）、双线性内插值、三次卷积法</p>\n<h4 id=\"最邻近差值：\"><a href=\"#最邻近差值：\" class=\"headerlink\" title=\"最邻近差值：\"></a><strong>最邻近差值：</strong></h4><p>对带小数的浮点坐标取整，得到整数型坐标。此坐标对应的像素值为目标像素的像素值。</p>\n<p>设目标图像像素映射到源图像坐标为 (x, y)，则：<br>$$<br>I’(i, j) &#x3D; I\\left(\\text{round}(x),\\ \\text{round}(y)\\right)<br>$$</p>\n<h4 id=\"双线性内插值：\"><a href=\"#双线性内插值：\" class=\"headerlink\" title=\"双线性内插值：\"></a><strong>双线性内插值：</strong></h4><p>从源图像中取出目标点周围的 4 个像素，按水平和垂直方向分别线性插值，进行二维线性插值。</p>\n<p>设源图像中整数像素点：</p>\n<ul>\n<li>$(x_0, y_0)$、$(x_1, y_0)$</li>\n<li>$(x_0, y_1)$、$(x_1, y_1)$，其中 $x_0 &#x3D; \\lfloor x \\rfloor$，$x_1 &#x3D; x_0 + 1$</li>\n</ul>\n<p>插值过程如下：<br>$$<br>I’(x, y) &#x3D; (1 - a)(1 - b) I(x_0, y_0) + a(1 - b) I(x_1, y_0) + (1 - a)b I(x_0, y_1) + ab I(x_1, y_1)<br>$$<br>其中：</p>\n<ul>\n<li>$a &#x3D; x - x_0$，</li>\n<li>$b &#x3D; y - y_0$</li>\n</ul>\n<h4 id=\"三次卷积法：\"><a href=\"#三次卷积法：\" class=\"headerlink\" title=\"三次卷积法：\"></a><strong>三次卷积法：</strong></h4><p>对目标点周围 $4 \\times 4 &#x3D; 16$ 个像素进行插值，采用三次卷积函数加权，精度更高。<br>$$<br>h(x) &#x3D;<br>\\begin{cases}<br>( a + 2)|x|^3 - (a + 3)|x|^2 + 1, &amp; 0 \\le |x| &lt; 1 \\<br>a|x|^3 - 5a|x|^2 + 8a|x| - 4a, &amp; 1 \\le |x| &lt; 2 \\<br>0, &amp; |x| \\ge 2<br>\\end{cases}<br>$$<br>其中，常用 $a &#x3D; -0.5$</p>\n<p>插值值由 16 点卷积结果计算：<br>$$<br>I’(x, y) &#x3D; \\sum_{i&#x3D;-1}^{2} \\sum_{j&#x3D;-1}^{2} I(x_i, y_j) \\cdot h(x - x_i) \\cdot h(y - y_j)<br>$$<br><strong>旋转函数：</strong></p>\n<p><code>B = imrotate(A,angle)</code>（A逆时针旋转angle角度，返回图像不做修剪，图像要增大）</p>\n<p><code>B = imrotate(A,angle,&#39;crop&#39;)</code>（A逆时针旋转angle角度，返回图像做修剪，图像大小不变）</p>\n<h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><p>$$<br>x_1 &#x3D; s_x \\cdot x_0,\\quad y_1 &#x3D; s_y \\cdot y_0<br>$$</p>\n<h1 id=\"begin-bmatrix-x-1-y-1-1-end-bmatrix-4\"><a href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-4\" class=\"headerlink\" title=\"$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\"></a>$$<br>\\begin{bmatrix}<br>x_1 \\<br>y_1 \\<br>1<br>\\end{bmatrix}</h1><p>\\begin{bmatrix}<br>s_x &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>x_0 \\<br>y_0 \\<br>1<br>\\end{bmatrix}<br>$$</p>\n<p>其中$S_x,S_y&gt;1$图像放大，$S_x,S_y&lt;1$图像缩小</p>\n<p><strong>按任意比例缩小</strong>：$S_x&#x3D;S_y&#x3D;S(S&lt;1)$，则需要计算选择的行列</p>\n<p>$M<em>N$大小的原图像缩小后为：$SM</em>SN$</p>\n<p>原图像$A(x,y)$,新图像$B(x,y)$,则：$B(x,y)&#x3D;A(int(x<em>S),int(y</em>S))$</p>\n<p><strong>按不同比例缩小会导致几何畸变</strong></p>\n<p><strong>按任意比例放大</strong>：$S_x&#x3D;S_y&#x3D;S(S&gt;1)$</p>\n<p>将原图像放大S倍，则要将一个像素值添在新图像的$S*S$的子块中。</p>\n<p>图像的放大：创立新的像素位置；给新的像素赋灰度值</p>\n<p><strong>最近邻域内插法（产生马赛克）</strong>：</p>\n<p>在原图像上寻找最靠近的像素并把它的灰度值赋给栅格上的新像素。$f(x’,y’) &#x3D; f(x,y)$</p>\n<p>缩放公式：<code>B=imresize(A.m)</code>（将A缩放m倍）</p>\n<h3 id=\"转置\"><a href=\"#转置\" class=\"headerlink\" title=\"转置\"></a>转置</h3><p>转置公式：$B&#x3D;A’$</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><h2 id=\"傅里叶变换\"><a href=\"#傅里叶变换\" class=\"headerlink\" title=\"傅里叶变换\"></a>傅里叶变换</h2><p>图像变换是将图像从空域变换到频域，在频域中对图像进行加工，再回到空域的过程。</p>\n<p><strong>空域——-&gt;频域：正变换</strong>（傅里叶变换）</p>\n<p><strong>频域——-&gt;空域：逆变换</strong>（傅里叶逆变换）</p>\n<h2 id=\"一维傅立叶变换的手动计算，从-f-计算-F\"><a href=\"#一维傅立叶变换的手动计算，从-f-计算-F\" class=\"headerlink\" title=\"一维傅立叶变换的手动计算，从 f 计算 F\"></a>一维傅立叶变换的手动计算，从 f 计算 F</h2><p>用于离散采样信号的频谱分析，实际中常用于计算机中的实现。</p>\n<p><strong>正变换（DFT）</strong>：<br>$$<br>X(k) &#x3D; \\frac{1}{N} \\sum_{k&#x3D;0}^{N-1} X(k) \\cdot e^{j \\frac{2\\pi}{N}kn}, \\quad k &#x3D; 0, 1, …, N-1<br>$$</p>\n<p><strong>逆变换（IDFT）</strong>：<br>$$<br>x(n)&#x3D; \\sum_{n&#x3D;0}^{N-1} x(n) \\cdot e^{-j \\frac{2\\pi}{N}kn}, \\quad n &#x3D; 0, 1, …, N-1<br>$$<br>其中：</p>\n<ul>\n<li>$x(n)$：长度为 $N$ 的离散时域序列</li>\n<li>$X(k)$：其对应的频域序列</li>\n<li>$N$：序列总长度</li>\n</ul>\n<h3 id=\"手动计算\"><a href=\"#手动计算\" class=\"headerlink\" title=\"手动计算\"></a>手动计算</h3><p><code>j</code> 是虚数单位<br>$$<br>e^{-j\\theta}&#x3D;cos\\theta-j*sin\\theta<br>$$</p>\n<p>$$<br>f[n] ;&#x3D;; {,1,,2,,3,,4,}, \\qquad N &#x3D; 4.<br>$$</p>\n<p>$$<br>F[k] ;&#x3D;; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n];e^{-,j,\\frac{2\\pi}{4}kn},<br>\\qquad k &#x3D; 0,1,2,3.<br>$$</p>\n<p>$$<br>\\begin{aligned}<br>F[0]<br>&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 0 \\cdot n}<br>&#x3D; \\frac{1}{4}\\bigl[f[0] + f[1] + f[2] + f[3]\\bigr] \\<br>&amp;&#x3D; \\frac{1}{4}(1 + 2 + 3 + 4)<br>&#x3D; \\frac{10}{4}<br>&#x3D; 2.5.<br>\\end{aligned}<br>$$</p>\n<p>$$<br>\\begin{aligned}<br>F[1]<br>&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 1 \\cdot n}<br>&#x3D; \\frac{1}{4}\\Bigl[<br>1\\cdot e^{-j\\cdot 0}</p>\n<ul>\n<li>2\\cdot e^{-j,\\frac{\\pi}{2}}</li>\n<li>3\\cdot e^{-j,\\pi}</li>\n<li>4\\cdot e^{-j,\\frac{3\\pi}{2}}<br>\\Bigr] \\[0.5em]<br>&amp;&#x3D; \\frac{1}{4}\\Bigl[<br>1\\cdot (1)</li>\n<li>2\\cdot (-,j)</li>\n<li>3\\cdot (-1)</li>\n<li>4\\cdot (,j)<br>\\Bigr]<br>&#x3D; \\frac{1}{4}\\Bigl[<br>1 - 2j - 3 + 4j<br>\\Bigr] \\[0.5em]<br>&amp;&#x3D; \\frac{1}{4}\\Bigl[<br>(1 - 3) + j,(4 - 2)<br>\\Bigr]<br>&#x3D; \\frac{1}{4}\\bigl[-2 + 2j\\bigr]<br>&#x3D; -,0.5 ;+; 0.5,j.<br>\\end{aligned}<br>$$</li>\n</ul>\n<p>$$<br>\\begin{aligned}<br>F[2]<br>&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 2 \\cdot n}<br>&#x3D; \\frac{1}{4}\\Bigl[<br>1\\cdot e^{-j\\cdot 0}</p>\n<ul>\n<li>2\\cdot e^{-j,\\pi}</li>\n<li>3\\cdot e^{-j,2\\pi}</li>\n<li>4\\cdot e^{-j,3\\pi}<br>\\Bigr] \\[0.5em]<br>&amp;&#x3D; \\frac{1}{4}\\Bigl[<br>1\\cdot (1)</li>\n<li>2\\cdot (-1)</li>\n<li>3\\cdot (1)</li>\n<li>4\\cdot (-1)<br>\\Bigr]<br>&#x3D; \\frac{1}{4}\\bigl[1 - 2 + 3 - 4\\bigr]<br>&#x3D; \\frac{-2}{4}<br>&#x3D; -,0.5.<br>\\end{aligned}<br>$$</li>\n</ul>\n<p>$$<br>\\begin{aligned}<br>F[3]<br>&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 3 \\cdot n}<br>&#x3D; \\frac{1}{4}\\Bigl[<br>1\\cdot e^{-j\\cdot 0}</p>\n<ul>\n<li>2\\cdot e^{-j,\\frac{3\\pi}{2}}</li>\n<li>3\\cdot e^{-j,3\\pi}</li>\n<li>4\\cdot e^{-j,\\frac{9\\pi}{2}}<br>\\Bigr] \\[0.5em]<br>&amp;&#x3D; \\frac{1}{4}\\Bigl[<br>1\\cdot (1)</li>\n<li>2\\cdot (,j)</li>\n<li>3\\cdot (-1)</li>\n<li>4\\cdot (-,j)<br>\\Bigr]<br>&#x3D; \\frac{1}{4}\\bigl[,1 + 2j - 3 - 4j\\bigr] \\[0.5em]<br>&amp;&#x3D; \\frac{1}{4}\\bigl[(1 - 3) + j,(2 - 4)\\bigr]<br>&#x3D; \\frac{1}{4}\\bigl[-2 - 2j\\bigr]<br>&#x3D; -,0.5 ;-; 0.5,j.<br>\\end{aligned}<br>$$</li>\n</ul>\n<p>$$<br>\\bigl{,F[0],,F[1],,F[2],,F[3],\\bigr}<br>&#x3D; {,2.5,; -0.5 + 0.5,j,; -0.5,; -0.5 - 0.5,j,}.<br>$$</p>\n<h2 id=\"二维傅里叶变换（编程实现）\"><a href=\"#二维傅里叶变换（编程实现）\" class=\"headerlink\" title=\"二维傅里叶变换（编程实现）\"></a>二维傅里叶变换（编程实现）</h2><p>简单黑色背景白色方块版</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 二值图像的二维傅里叶变换及频谱显示</span></span><br><span class=\"line\">clear; clc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%% 1. 创建一个 300×300 的二值图像，中心为白色方块</span></span><br><span class=\"line\">A = <span class=\"built_in\">zeros</span>(<span class=\"number\">300</span>, <span class=\"number\">300</span>);                  <span class=\"comment\">% 黑色背景图像</span></span><br><span class=\"line\">A(<span class=\"number\">100</span>:<span class=\"number\">200</span>, <span class=\"number\">100</span>:<span class=\"number\">200</span>) = <span class=\"number\">1</span>;             <span class=\"comment\">% 中心插入一个 101×101 的白色正方形</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\">imshow(A); title(<span class=\"string\">&#x27;原始图像&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">pause;  <span class=\"comment\">% 等待查看原图，按任意键继续</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%% 2. 计算图像的二维傅里叶变换</span></span><br><span class=\"line\">F = fft2(A);                         <span class=\"comment\">% 计算二维快速傅里叶变换</span></span><br><span class=\"line\">F_mag = <span class=\"built_in\">abs</span>(F);                      <span class=\"comment\">% 取复数频谱的幅度（模）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%% 3. 将频谱中心化，并进行对数变换提升可视化效果</span></span><br><span class=\"line\">F_shifted = fftshift(F_mag);         <span class=\"comment\">% 将低频移到中心</span></span><br><span class=\"line\">F_log = <span class=\"built_in\">log</span>(<span class=\"number\">1</span> + F_shifted);          <span class=\"comment\">% 对数变换，压缩动态范围</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 归一化到 [0, 1] 区间，便于使用 imshow 显示</span></span><br><span class=\"line\">F_display = mat2gray(F_log);         </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%% 4. 显示频谱图像</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\">imshow(F_display, []);</span><br><span class=\"line\">title(<span class=\"string\">&#x27;频谱图（对数变换后）&#x27;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>图片版</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                        <span class=\"comment\">% 清除工作区变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 1. 读取图像并显示</span></span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;lena.bmp&#x27;</span>);       <span class=\"comment\">% 读取 lena 图像</span></span><br><span class=\"line\">imshow(A);</span><br><span class=\"line\">pause;                        <span class=\"comment\">% 暂停，按任意键继续</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 2. 将图像转换为 double 类型</span></span><br><span class=\"line\">A1 = im2double(A);            <span class=\"comment\">% 避免整数溢出问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 3. 计算二维傅里叶变换</span></span><br><span class=\"line\">B = fft2(A1);                 <span class=\"comment\">% 快速傅里叶变换（复数结果）</span></span><br><span class=\"line\">C = <span class=\"built_in\">abs</span>(B);                   <span class=\"comment\">% 取幅度谱</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 4. 中心化频谱图</span></span><br><span class=\"line\">D = fftshift(C);              <span class=\"comment\">% 将低频移到中心</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 5. 显示频谱图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\">D1 = uint8(D);</span><br><span class=\"line\">imshow(D1);</span><br></pre></td></tr></table></figure>\n\n<p>傅里叶变换性质：</p>\n<p>平移性：在空域中图像平移，频域中频谱不变</p>\n<p>旋转性：在空域中旋转a角度，在频域中也旋转a角度</p>\n<h2 id=\"傅里叶变换两个应用\"><a href=\"#傅里叶变换两个应用\" class=\"headerlink\" title=\"傅里叶变换两个应用\"></a>傅里叶变换两个应用</h2><h3 id=\"双谱重构\"><a href=\"#双谱重构\" class=\"headerlink\" title=\"双谱重构\"></a>双谱重构</h3><p>**图像的频谱：**代表图像各像素点的亮度信息，即像素显示什么颜色</p>\n<p>**图像的相位谱：**记录图像各像素点位置信息</p>\n<p>利用两个图像的频谱和相位谱，<strong>交换相位谱</strong>，进行双谱重构。<strong>重构出来的图像的轮廓信息与相位谱对应。</strong></p>\n<h3 id=\"模版匹配定位\"><a href=\"#模版匹配定位\" class=\"headerlink\" title=\"模版匹配定位\"></a>模版匹配定位</h3><p>模版匹配：一种最基本的模式识别方法。研究特定模版图像位于目标图像什么位置，进而识别该图像。</p>\n<p><strong>模版匹配定位是卷机运算的一个应用</strong></p>\n<p>注意：空域的卷积运算等同于频域的点乘运算</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear all;</span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;text.png&#x27;</span>);      <span class=\"comment\">% 必须是黑白二值图</span></span><br><span class=\"line\">imshow(A);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 取子图像为模板图像</span></span><br><span class=\"line\">B = A(<span class=\"number\">29</span>:<span class=\"number\">46</span>, <span class=\"number\">86</span>:<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"built_in\">figure</span>, imshow(B);</span><br><span class=\"line\"></span><br><span class=\"line\">B(<span class=\"number\">256</span>,<span class=\"number\">256</span>) = <span class=\"number\">0</span>;              <span class=\"comment\">% 扩展模板图像为大图大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 将模板图像与目标图像进行卷积运算</span></span><br><span class=\"line\">C = fft2(A) .* fft2(<span class=\"built_in\">rot90</span>(B,<span class=\"number\">2</span>));</span><br><span class=\"line\">CI = <span class=\"built_in\">real</span>(ifft2(C));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">figure</span>, imshow(CI, []);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 取阈值</span></span><br><span class=\"line\">thresh = <span class=\"number\">58</span>;</span><br><span class=\"line\"><span class=\"built_in\">figure</span>, imshow(CI &gt; thresh);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"离散余弦变换\"><a href=\"#离散余弦变换\" class=\"headerlink\" title=\"离散余弦变换\"></a>离散余弦变换</h2><p>DCT 是一种将信号从“空间域”转化为“频率域”的变换方法，能把图像中的大部分能量集中在少量低频分量中。</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实数变换</td>\n<td>DCT 不涉及复数，计算更简单快速</td>\n</tr>\n<tr>\n<td>能量集中性强</td>\n<td>图像或信号的主要信息集中于变换后的前几个系数</td>\n</tr>\n<tr>\n<td>常用于压缩编码</td>\n<td>如 JPEG 图像压缩、MP3 音频压缩中都用到 DCT</td>\n</tr>\n<tr>\n<td>可逆性</td>\n<td>可通过**逆离散余弦变换（IDCT）**恢复原始信号</td>\n</tr>\n</tbody></table>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><h2 id=\"图像灰度拉伸\"><a href=\"#图像灰度拉伸\" class=\"headerlink\" title=\"图像灰度拉伸\"></a>图像灰度拉伸</h2><p>将原始图像灰度区分为多段，分别做线性变换，即分段线性变换<br>$$<br>G(F) &#x3D;<br>\\begin{cases}<br>\\frac{a’}{a} \\cdot F, &amp; 0 \\leq F &lt; a \\<br>\\frac{b’ - a’}{b - a} \\cdot (F - a) + a’, &amp; a \\leq F &lt; b \\<br>\\frac{M’ - b’}{M - b} \\cdot (F - b) + b’, &amp; b \\leq F \\leq M<br>\\end{cases}<br>$$<br>可以拉伸$[a,b]$区间，让它斜率大于1，来改善区间内图像效果。即$|b’-a’|&gt;|b-a|$</p>\n<p><strong>注意</strong>：小于a区间和大于b区间的图像，会造成信息丢失（斜率&lt;1）</p>\n<p>灰度拉伸函数：<code>Y=imadjust(X,[a,b],[a&#39;,b&#39;]);</code>（将X转换为Y，在$[a,b]$内的灰度值对应转为$[a’,b’]$，灰度值要归一）</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear; </span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;ballet.bmp&#x27;</span>);       <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>); imshow(A);      <span class=\"comment\">% 显示原图像</span></span><br><span class=\"line\">pause;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 图像增强：线性灰度拉伸，输入范围 [0.1, 0.25] 映射到 [0, 0.8]</span></span><br><span class=\"line\">B = imadjust(A, [<span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>], [<span class=\"number\">0</span>, <span class=\"number\">0.8</span>]); </span><br><span class=\"line\"></span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>); imshow(B);      <span class=\"comment\">% 显示增强后的图像</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"直方图均衡化\"><a href=\"#直方图均衡化\" class=\"headerlink\" title=\"直方图均衡化\"></a>直方图均衡化</h2><h3 id=\"手工计算\"><a href=\"#手工计算\" class=\"headerlink\" title=\"手工计算\"></a>手工计算</h3><p>直方图均衡化步骤：</p>\n<p><strong>1. 给出所有灰度级 $r_k$（$k &#x3D; 0, \\ldots, L - 1$）的所有概率值 $P_r$：</strong></p>\n<ul>\n<li><p>设 $n_j$ 为灰度级 $r_j$ 的像素个数，总像素为 $n$</p>\n</li>\n<li><p>则概率：<br>$$<br>p_r(r_j) &#x3D; \\frac{n_j}{n}<br>$$</p>\n</li>\n</ul>\n<p><strong>2. 求出累积分布函数 $s_k$：</strong><br>$$<br>s_k &#x3D; T(r_k) &#x3D; \\sum_{j&#x3D;0}^{k} p_r(r_j) \\approx \\sum_{j&#x3D;0}^{k} \\frac{n_j}{n} \\quad \\text{，其中 } k &#x3D; 0,1,2,\\dots,L-1<br>$$<br><strong>3. 对 $s_k$ 四舍五入取整：</strong><br>$$<br>s_k &#x3D; \\text{int}\\left[ (L-1) \\cdot s_k + 0.5 \\right]<br>$$</p>\n<ul>\n<li>表格里计算的时候不用加0.5</li>\n<li>将归一化的灰度值映射回 $[0, L-1]$ 范围内的整数</li>\n</ul>\n<p><strong>4. 确定映射关系：</strong><br>$$<br>r_k \\rightarrow s_k<br>$$</p>\n<ul>\n<li>即原灰度 $r_k$ 映射到新的灰度 $s_k$</li>\n</ul>\n<p><strong>5. 计算新的概率值 $P’_r$：</strong></p>\n<ul>\n<li>用新灰度值统计直方图，生成新的概率分布 $P’_r$</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>灰度级 $r_k$</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>原始直方图 $P_r$</td>\n<td>0.19</td>\n<td>0.25</td>\n<td>0.21</td>\n<td>0.16</td>\n<td>0.08</td>\n<td>0.06</td>\n<td>0.03</td>\n<td>0.02</td>\n</tr>\n<tr>\n<td>累积直方图 $S_k$</td>\n<td>0.19</td>\n<td>0.44</td>\n<td>0.65</td>\n<td>0.81</td>\n<td>0.89</td>\n<td>0.95</td>\n<td>0.98</td>\n<td>1.00</td>\n</tr>\n<tr>\n<td>$S_k$ 变换：$(L-1) \\cdot S_k$</td>\n<td>1.33</td>\n<td>3.33</td>\n<td>4.55</td>\n<td>5.67</td>\n<td>6.23</td>\n<td>6.65</td>\n<td>6.86</td>\n<td>7.00</td>\n</tr>\n<tr>\n<td>四舍五入取整 $s_k$</td>\n<td>1</td>\n<td>3</td>\n<td>5</td>\n<td>6</td>\n<td>6</td>\n<td>7</td>\n<td>7</td>\n<td>7</td>\n</tr>\n<tr>\n<td>映射关系 $r_k \\rightarrow s_k$</td>\n<td>0→1</td>\n<td>1→3</td>\n<td>2→5</td>\n<td>3→6</td>\n<td>4→6</td>\n<td>5→7</td>\n<td>6→7</td>\n<td>7→7</td>\n</tr>\n<tr>\n<td>新直方图 $P’_r$</td>\n<td>0</td>\n<td>0.19</td>\n<td>0</td>\n<td>0.25</td>\n<td>0</td>\n<td>0.21</td>\n<td>0.24</td>\n<td>0.11</td>\n</tr>\n</tbody></table>\n<p>直方图均衡化函数：<code>Y=histeq(X)</code>（将X的直方图均衡化为Y）</p>\n<p><code>imhist(X)</code>（显示X的直方图）</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;</span><br><span class=\"line\"><span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;pout.tif&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">% 显示原图像</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>), imshow(A);</span><br><span class=\"line\"><span class=\"comment\">% 进行直方图均衡化</span></span><br><span class=\"line\">B = histeq(A);</span><br><span class=\"line\"><span class=\"comment\">% 显示均衡化后的图像</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>), imshow(B);</span><br><span class=\"line\"><span class=\"comment\">% 显示原图的直方图</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), imhist(A);</span><br><span class=\"line\"><span class=\"comment\">% 显示均衡化图的直方图</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>), imhist(B);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"直方图的归并化手工计算（SML单映射表）\"><a href=\"#直方图的归并化手工计算（SML单映射表）\" class=\"headerlink\" title=\"直方图的归并化手工计算（SML单映射表）\"></a>直方图的归并化手工计算（SML单映射表）</h3><p><strong>每个灰度级分别和规定直方图相减并取绝对值，取绝对值最小的那个规定灰度级，然后映射</strong></p>\n<table>\n<thead>\n<tr>\n<th>灰度级 $r_k$</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>原始直方图 $P_r$</td>\n<td>0.19</td>\n<td>0.25</td>\n<td>0.21</td>\n<td>0.16</td>\n<td>0.08</td>\n<td>0.06</td>\n<td>0.03</td>\n<td>0.02</td>\n</tr>\n<tr>\n<td>原始累计直方图 $S_k$</td>\n<td>0.19</td>\n<td>0.44</td>\n<td>0.65</td>\n<td>0.81</td>\n<td>0.89</td>\n<td>0.95</td>\n<td>0.98</td>\n<td>1.00</td>\n</tr>\n<tr>\n<td>规定直方图 $P’_z$</td>\n<td></td>\n<td></td>\n<td></td>\n<td>0.20</td>\n<td></td>\n<td>0.60</td>\n<td></td>\n<td>0.20</td>\n</tr>\n<tr>\n<td>规定累计直方图</td>\n<td></td>\n<td></td>\n<td></td>\n<td>0.20</td>\n<td></td>\n<td>0.80</td>\n<td></td>\n<td>1.00</td>\n</tr>\n<tr>\n<td>SML 映射</td>\n<td>3</td>\n<td>3</td>\n<td>5</td>\n<td>5</td>\n<td>5</td>\n<td>7</td>\n<td>7</td>\n<td>7</td>\n</tr>\n<tr>\n<td>映射对应关系</td>\n<td>0→3</td>\n<td>1→3</td>\n<td>2→5</td>\n<td>3→5</td>\n<td>4→5</td>\n<td>5→7</td>\n<td>6→7</td>\n<td>7→7</td>\n</tr>\n<tr>\n<td>转换后的直方图</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0.44</td>\n<td>0</td>\n<td>0.45</td>\n<td>0</td>\n<td>0.11</td>\n</tr>\n</tbody></table>\n<h2 id=\"空域滤波\"><a href=\"#空域滤波\" class=\"headerlink\" title=\"空域滤波\"></a>空域滤波</h2><p>定义：在图像空间借助模版进行邻域操作的过程</p>\n<p>空域滤波器：上述过程中的模版</p>\n<p>模版定义：一个系数矩阵，通常为奇数（$3<em>3$，$5</em>5$，$7*7$）</p>\n<p>运算过程：模板在图像上滑动，每个位置计算对应区域的加权和（即卷积操作）。</p>\n<p>模板系数矩阵<br>$$<br>\\begin{bmatrix}<br>k1 &amp; k2 &amp; k3 \\<br>k4 &amp; k5 &amp; k6 \\<br>k7 &amp; k8 &amp; k9 \\<br>\\end{bmatrix}<br>$$<br>图像局部灰度矩阵<br>$$<br>\\begin{bmatrix}<br>s1 &amp; s2 &amp; s3 \\<br>s4 &amp; s5 &amp; s6 \\<br>s7 &amp; s8 &amp; s9 \\<br>\\end{bmatrix}<br>$$<br>求和符号形式（紧凑表示）：<br>$$<br>R &#x3D; \\sum_{i&#x3D;1}^{9} k_i \\cdot s_i<br>$$<br>展开形式：<br>$$<br>R &#x3D; k_1 s_1 + k_2 s_2 + k_3 s_3 + k_4 s_4 + k_5 s_5 + k_6 s_6 + k_7 s_7 + k_8 s_8 + k_9 s_9<br>$$<br>分类：平滑（消除噪声）、锐化（加强图像中的边缘和轮廓）</p>\n<p>平滑：均值滤波，中值滤波</p>\n<h3 id=\"均值滤波（平滑）\"><a href=\"#均值滤波（平滑）\" class=\"headerlink\" title=\"均值滤波（平滑）\"></a>均值滤波（平滑）</h3><p>均值滤波：将一个像元及其邻域中所有像元的灰度平均赋给输出图像的相应像元，达到平滑目的</p>\n<p>均值滤波模版：模版系数都为1，大小为$3<em>3$，$5</em>5$，$7*7$</p>\n<p><strong>实例</strong></p>\n<p>输入子图像灰度矩阵（3×3）<br>$$<br>\\begin{bmatrix}<br>2 &amp; 2 &amp; 3 \\<br>7 &amp; 6 &amp; 8 \\<br>7 &amp; 6 &amp; 8 \\<br>\\end{bmatrix}<br>$$<br>模板（均值滤波）</p>\n<p>使用 <strong>3×3 均值滤波器</strong>，模板系数为均匀权重，归一化后为：<br>$$<br>\\frac{1}{9}<br>\\begin{bmatrix}<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1 \\<br>\\end{bmatrix}<br>$$<br>计算过程（模板与图像对应元素相乘并求和）</p>\n<p>计算方式为：<br>$$<br>R &#x3D; \\frac{1}{9} \\times (2 + 2 + 3 + 7 + 6 + 8 + 7 + 6 + 8)<br>$$<br>取整后输出灰度值：<br>$$<br>R \\approx 5<br>$$<br>输出图像灰度矩阵（仅中心像素更新）<br>$$<br>\\begin{bmatrix}</p>\n<ul>\n<li>&amp; - &amp; - \\</li>\n<li>&amp; 5 &amp; - \\</li>\n<li>&amp; - &amp; - \\<br>\\end{bmatrix}<br>$$<br><strong>注：模版尺寸越大，对噪声消除效果越强，但图像越模糊</strong></li>\n</ul>\n<p><strong>均值滤波函数：</strong>$h&#x3D;ones(m,m)&#x2F;m^2$（产生一个大小为$m*m$的模版）</p>\n<p><code>B=imfilter(A,h)</code>（将A用模版h作均值滤波）</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;face_1.bmp&#x27;</span>); <span class=\"comment\">% 读取图像文件</span></span><br><span class=\"line\">imshow(A);            <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 3×3 均值滤波</span></span><br><span class=\"line\">h1 = <span class=\"built_in\">ones</span>(<span class=\"number\">3</span>,<span class=\"number\">3</span>)/<span class=\"number\">9</span>;     <span class=\"comment\">% 创建3×3归一化均值模板（每个系数=1/9）</span></span><br><span class=\"line\">B1 = imfilter(A, h1); <span class=\"comment\">% 对图像A应用模板h1</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B1);    <span class=\"comment\">% 显示滤波结果B1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 7×7 均值滤波</span></span><br><span class=\"line\">h2 = <span class=\"built_in\">ones</span>(<span class=\"number\">7</span>,<span class=\"number\">7</span>)/<span class=\"number\">49</span>;    <span class=\"comment\">% 创建7×7归一化均值模板（每个系数=1/49）</span></span><br><span class=\"line\">B2 = imfilter(A, h2); <span class=\"comment\">% 对图像A应用模板h2</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B2);    <span class=\"comment\">% 显示滤波结果B2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"中值滤波（平滑）\"><a href=\"#中值滤波（平滑）\" class=\"headerlink\" title=\"中值滤波（平滑）\"></a>中值滤波（平滑）</h3><p>中值滤波：用一个模版窗口在图像上滑动，把窗口中像素灰度按值升次排序，将中间值赋给窗口中心的像素。</p>\n<p>优点：抑制噪声，较好的保护边缘轮廓信息</p>\n<p><strong>实例</strong></p>\n<p>子图像灰度矩阵（3×3）<br>$$<br>\\begin{bmatrix}<br>8 &amp; 2 &amp; 4 \\<br>3 &amp; 2 &amp; 5 \\<br>4 &amp; 6 &amp; 4 \\<br>\\end{bmatrix}<br>$$<br>模板（3×3）<br>$$<br>\\begin{bmatrix}<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 1 \\<br>\\end{bmatrix}<br>$$<br>提取局部像素值</p>\n<p>将子图像矩阵按行展开为一维数组：<br>$$<br>[8, 2, 4, 3, 2, 5, 4, 6, 4]<br>$$<br> 排序</p>\n<p>升序排列后为：<br>$$<br>[2, 2, 3, 4, 4, 4, 5, 6, 8]<br>$$<br>输出灰度值</p>\n<p>取排序中间值（第 5 个元素）为：<br>$$<br>R &#x3D; 4<br>$$<br>输出图像灰度矩阵（仅更新中心像素）<br>$$<br>\\begin{bmatrix}</p>\n<ul>\n<li>&amp; - &amp; - \\</li>\n<li>&amp; 4 &amp; - \\</li>\n<li>&amp; - &amp; - \\<br>\\end{bmatrix}<br>$$<br><strong>注：中值滤波后图像轮廓比较清晰</strong></li>\n</ul>\n<p><strong>中值滤波函数：</strong><code>B=medfilt2(A,[m m])</code>（将A用模版$m*m$做中值滤波）</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;face_1.bmp&#x27;</span>); <span class=\"comment\">% 读取图像文件</span></span><br><span class=\"line\">imshow(A);            <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 3×3 中值滤波</span></span><br><span class=\"line\">B1 = medfilt2(A, [<span class=\"number\">3</span> <span class=\"number\">3</span>]); <span class=\"comment\">% 对图像A应用3×3中值滤波</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B1);    <span class=\"comment\">% 显示滤波结果B1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 5×5 中值滤波</span></span><br><span class=\"line\">B2 = medfilt2(A, [<span class=\"number\">5</span> <span class=\"number\">5</span>]); <span class=\"comment\">% 对图像A应用5×5中值滤波</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B2);    <span class=\"comment\">% 显示滤波结果B2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"滤波与噪声\"><a href=\"#滤波与噪声\" class=\"headerlink\" title=\"滤波与噪声\"></a>滤波与噪声</h3><p>噪声：电磁波干扰，光电基本性质，机械运动，元件本身缺陷，电路噪声</p>\n<p>三种噪声：椒盐，高斯，斑点</p>\n<p>**椒盐噪声：**由于图像传感器等产生的黑白相间的噪声，<strong>用中值滤波去除</strong></p>\n<p>**高斯噪声：**其密度符合高斯分布，一种随机噪声。<strong>用均值滤波去除</strong></p>\n<p>斑点噪声：一种均值为1的乘性噪声，模型为$I(x,y)&#x3D;R(x,y)*F(x,y)$</p>\n<p>其中：$(x,y)$代表图像单元空间方向及距离向坐标</p>\n<p>$I(x,y)$代表所接受的受噪声干扰的SAR图像信息</p>\n<p>R代表未受噪声干扰的SAR图像信息</p>\n<p>F代表与R相对独立的斑点噪声随机变量</p>\n<p><strong>添加噪声：</strong></p>\n<p><code>B=imnoise(A,&#39;salt &amp; pepper&#39;,d)</code>（给A增加椒盐噪声）</p>\n<p>d为椒盐噪声的密度，缺省值为0.05</p>\n<p><code>B=imnoise(A,&#39;gaussian&#39;,m,v)</code>（给A增加高斯白噪声）</p>\n<p>m为噪声的白色程度，缺省值为0</p>\n<p>v为噪声的密度，缺省值为0.01</p>\n<h3 id=\"锐化滤波（锐化）（sobel算子）\"><a href=\"#锐化滤波（锐化）（sobel算子）\" class=\"headerlink\" title=\"锐化滤波（锐化）（sobel算子）\"></a>锐化滤波（锐化）（sobel算子）</h3><p>加强图像中景物的边缘和轮廓。锐化的作用是要使灰度反查增强。</p>\n<p>水平方向（检测垂直边缘）</p>\n<p> 数学表达：<br>$$<br>\\frac{\\partial f(x, y)}{\\partial x}<br>$$<br>Sobel模板（X方向）：<br>$$<br>G_x &#x3D;<br>\\begin{bmatrix}<br>1 &amp; 0 &amp; -1 \\<br>2 &amp; 0 &amp; -2 \\<br>1 &amp; 0 &amp; -1 \\<br>\\end{bmatrix}<br>$$<br>作用：</p>\n<ul>\n<li>检测图像中 <strong>垂直边缘</strong>（例如：建筑物轮廓、柱子）</li>\n<li>强调图像中水平方向的灰度变化</li>\n</ul>\n<p>垂直方向（检测水平方向边缘）</p>\n<p>数学表达：<br>$$<br>\\frac{\\partial f(x, y)}{\\partial y}<br>$$<br>Sobel模板（Y方向）：<br>$$<br>G_y &#x3D;<br>\\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>0 &amp; 0 &amp; 0 \\<br>-1 &amp; -2 &amp; -1 \\<br>\\end{bmatrix}<br>$$<br> 作用：</p>\n<ul>\n<li>检测图像中 <strong>水平边缘</strong>（例如：地平线、桌面边缘）</li>\n<li>强调图像中垂直方向的灰度变化</li>\n</ul>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;bot.bmp&#x27;</span>); <span class=\"comment\">% 读取图像文件</span></span><br><span class=\"line\">imshow(A);            <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 水平方向Sobel算子（检测垂直边缘）</span></span><br><span class=\"line\">h1 = [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">1</span>; <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>; <span class=\"number\">-1</span> <span class=\"number\">-2</span> <span class=\"number\">-1</span>]; <span class=\"comment\">% 水平方向模板</span></span><br><span class=\"line\">B1 = imfilter(A, h1);          <span class=\"comment\">% 应用水平方向滤波</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B1);            <span class=\"comment\">% 显示水平边缘检测结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 垂直方向Sobel算子（检测水平边缘）</span></span><br><span class=\"line\">h2 = [<span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">-1</span>; <span class=\"number\">2</span> <span class=\"number\">0</span> <span class=\"number\">-2</span>; <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">-1</span>]; <span class=\"comment\">% 垂直方向模板</span></span><br><span class=\"line\">B2 = imfilter(A, h2);          <span class=\"comment\">% 应用垂直方向滤波</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B2);            <span class=\"comment\">% 显示垂直边缘检测结果</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"频域滤波\"><a href=\"#频域滤波\" class=\"headerlink\" title=\"频域滤波\"></a>频域滤波</h2><p>图像<strong>变化平缓</strong>的部分靠近频域的圆心——-&gt;低频区域</p>\n<p>图像中<strong>边缘、噪音、变化陡峻</strong>的部分，以放射方向离开频域的圆心—–&gt;高频区域</p>\n<p><img src=\"/../images/1.png\"></p>\n<h3 id=\"理想滤波器\"><a href=\"#理想滤波器\" class=\"headerlink\" title=\"理想滤波器\"></a>理想滤波器</h3><h4 id=\"低通滤波\"><a href=\"#低通滤波\" class=\"headerlink\" title=\"低通滤波\"></a>低通滤波</h4><p>过滤<strong>边缘，噪音，变化陡峻</strong>的所在的高频分量，保留图像中<strong>变化平缓</strong>的低频分量，使图像平滑。</p>\n<p><strong>理想低通滤波器（Ideal Lowpass Filter, ILPF）</strong></p>\n<p>基本定义：</p>\n<p>理想低通滤波器（ILPF）是<strong>频域滤波器</strong>，用于<strong>仅保留低频成分</strong>（平坦区域、缓变纹理），<strong>完全截断高频成分</strong>（边缘、细节、噪声等）。</p>\n<p>滤波器传递函数：<br>$$<br>H(u, v) &#x3D;<br>\\begin{cases}<br>1, &amp; D(u, v) \\leq D_0 \\<br>0, &amp; D(u, v) &gt; D_0<br>\\end{cases}<br>$$</p>\n<ul>\n<li>$H(u, v)$：滤波器在频域中对频率点 $(u, v)$ 的响应</li>\n<li>$D(u, v)$：该频率点到频谱中心的距离</li>\n<li>$D_0$：<strong>截止频率</strong>（控制保留频率的范围）</li>\n</ul>\n<p> 距离函数定义：<br>$$<br>D(u, v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}<br>$$</p>\n<ul>\n<li>$M, N$：图像尺寸（频谱大小）</li>\n<li>$(M&#x2F;2, N&#x2F;2)$：频谱中心，即 DC 分量所在位置</li>\n</ul>\n<p><strong>关键特性</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>理想性</strong></td>\n<td>理想低通滤波器有明确的频率截断点，没有过渡区域</td>\n</tr>\n<tr>\n<td><strong>硬截断</strong></td>\n<td>高频分量被<strong>完全移除</strong>，仅低于 $D_0$ 的频率通过</td>\n</tr>\n<tr>\n<td><strong>振铃效应</strong></td>\n<td>突变的频率截断在空间域中造成振荡现象（Gibbs 现象）</td>\n</tr>\n<tr>\n<td><strong>能量集中</strong></td>\n<td>保留图像大致轮廓与平滑区域，损失细节与边缘</td>\n</tr>\n</tbody></table>\n<p>物理意义图示（简略）：</p>\n<ul>\n<li>若 $H(u,v) &#x3D; 1$：频率 $(u,v)$ <strong>被保留</strong></li>\n<li>若 $H(u,v) &#x3D; 0$：频率 $(u,v)$ <strong>被阻断</strong></li>\n</ul>\n<p>实际应用提示：</p>\n<ul>\n<li><strong>优点</strong>：理论分析简单，便于理解频域滤波思想</li>\n<li><strong>缺点</strong>：实际图像中常产生明显振铃（ringing）和伪影，影响视觉质量</li>\n<li><strong>替代方案</strong>：高斯低通滤波器（Gaussian LPF）、巴特沃斯低通（Butterworth LPF）等，具有平滑过渡带</li>\n</ul>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                    <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">f = imread(<span class=\"string\">&#x27;saturn_1.bmp&#x27;</span>); <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">imshow(f);                <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\">f = im2double(f);         <span class=\"comment\">% 转换为双精度浮点（范围[0,1]）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 傅里叶变换并中心化频谱</span></span><br><span class=\"line\">F = fftshift(fft2(f));    <span class=\"comment\">% fft2计算二维DFT，fftshift将零频移至中心</span></span><br><span class=\"line\">[M, N] = <span class=\"built_in\">size</span>(F);         <span class=\"comment\">% 获取频谱尺寸</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 理想低通滤波参数</span></span><br><span class=\"line\">D0 = <span class=\"number\">30</span>;                  <span class=\"comment\">% 截止频率（半径阈值）</span></span><br><span class=\"line\">u0 = <span class=\"built_in\">floor</span>(M/<span class=\"number\">2</span>);          <span class=\"comment\">% 频谱中心行坐标</span></span><br><span class=\"line\">v0 = <span class=\"built_in\">floor</span>(N/<span class=\"number\">2</span>);          <span class=\"comment\">% 频谱中心列坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 遍历频谱，生成滤波器掩膜</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> u = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        D = <span class=\"built_in\">sqrt</span>((u-u0)^<span class=\"number\">2</span> + (v-v0)^<span class=\"number\">2</span>); <span class=\"comment\">% 计算(u,v)到中心的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> D &gt; D0</span><br><span class=\"line\">            G(u,v) = <span class=\"number\">0</span>;   <span class=\"comment\">% 高频部分置零</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            G(u,v) = F(u,v); <span class=\"comment\">% 保留低频部分</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 反变换回空间域</span></span><br><span class=\"line\">g = ifft2(ifftshift(G));  <span class=\"comment\">% 逆中心化后逆傅里叶变换</span></span><br><span class=\"line\">g = im2uint8(<span class=\"built_in\">real</span>(g));    <span class=\"comment\">% 取实部并转换为8位图像</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(g);        <span class=\"comment\">% 显示滤波结果</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"高通滤波\"><a href=\"#高通滤波\" class=\"headerlink\" title=\"高通滤波\"></a>高通滤波</h4><p><strong>理想高通滤波器（Ideal Highpass Filter, IHPF）</strong></p>\n<p>基本定义：</p>\n<p>理想高通滤波器通过保留频谱中的<strong>高频分量</strong>（边缘、纹理、细节），<strong>完全阻断低频分量</strong>（均匀背景、缓慢过渡区域）。其<strong>频域传递函数</strong>为：<br>$$<br>H(u, v) &#x3D;<br>\\begin{cases}<br>0, &amp; D(u, v) \\leq D_0 \\<br>1, &amp; D(u, v) &gt; D_0<br>\\end{cases}<br>$$</p>\n<ul>\n<li>$D_0$：<strong>截止频率</strong>，决定阻断范围</li>\n<li>$D(u, v)$：频率点 $(u, v)$ 到频谱中心 $(M&#x2F;2, N&#x2F;2)$ 的距离</li>\n<li>计算公式：</li>\n</ul>\n<p>$$<br>D(u, v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}<br>$$</p>\n<p> <strong>关键特性</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>理想性</strong></td>\n<td>完全区分高频与低频，没有过渡带</td>\n</tr>\n<tr>\n<td><strong>作用</strong></td>\n<td>高通：增强细节、边缘；压制平滑区域</td>\n</tr>\n<tr>\n<td><strong>副作用</strong></td>\n<td>高频截断太陡，空间域中易出现<strong>振铃效应（Gibbs 现象）</strong></td>\n</tr>\n</tbody></table>\n<p>物理意义：</p>\n<ul>\n<li>$H(u,v) &#x3D; 0$：该频率分量被阻断（平坦区域）</li>\n<li>$H(u,v) &#x3D; 1$：该频率分量通过（图像细节、纹理）</li>\n</ul>\n<p>实际应用建议替代方案：</p>\n<table>\n<thead>\n<tr>\n<th>滤波器类型</th>\n<th>特点</th>\n<th>振铃效应</th>\n<th>场景推荐</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>理想高通（IHPF）</strong></td>\n<td>硬截断</td>\n<td>严重</td>\n<td>理论教学，分析用</td>\n</tr>\n<tr>\n<td><strong>巴特沃斯高通（BHPF）</strong></td>\n<td>平滑过渡</td>\n<td>轻微</td>\n<td>图像处理通用</td>\n</tr>\n<tr>\n<td><strong>高斯高通（GHPF）</strong></td>\n<td>无振铃，过渡自然</td>\n<td>无</td>\n<td>医学图像，高精度场景</td>\n</tr>\n</tbody></table>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                          <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">f = imread(<span class=\"string\">&#x27;saturn_1.bmp&#x27;</span>);     <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">imshow(f);                      <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\">f = im2double(f);               <span class=\"comment\">% 转换为双精度浮点（范围[0,1]）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 傅里叶变换并中心化频谱</span></span><br><span class=\"line\">F = fftshift(fft2(f));          <span class=\"comment\">% 计算DFT并中心化</span></span><br><span class=\"line\">[M, N] = <span class=\"built_in\">size</span>(F);               <span class=\"comment\">% 获取频谱尺寸</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 理想高通滤波参数</span></span><br><span class=\"line\">D0 = <span class=\"number\">30</span>;                        <span class=\"comment\">% 截止频率（半径阈值）</span></span><br><span class=\"line\">u0 = <span class=\"built_in\">floor</span>(M/<span class=\"number\">2</span>);                <span class=\"comment\">% 频谱中心行坐标</span></span><br><span class=\"line\">v0 = <span class=\"built_in\">floor</span>(N/<span class=\"number\">2</span>);                <span class=\"comment\">% 频谱中心列坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 初始化掩膜矩阵</span></span><br><span class=\"line\">G = <span class=\"built_in\">zeros</span>(M, N);                <span class=\"comment\">% 初始化为全零（阻断所有）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 构建高通滤波掩膜：保留高频，去除低频</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> u = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        D = <span class=\"built_in\">sqrt</span>((u - u0)^<span class=\"number\">2</span> + (v - v0)^<span class=\"number\">2</span>);  <span class=\"comment\">% 到频谱中心的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> D &gt; D0</span><br><span class=\"line\">            G(u, v) = F(u, v);  <span class=\"comment\">% 高频保留</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            G(u, v) = <span class=\"number\">0</span>;        <span class=\"comment\">% 低频抑制</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 反变换回空间域</span></span><br><span class=\"line\">g = ifft2(ifftshift(G));        <span class=\"comment\">% 逆中心化+逆傅里叶变换</span></span><br><span class=\"line\">g = im2uint8(<span class=\"built_in\">real</span>(g));          <span class=\"comment\">% 取实部并转换为8位图像</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(g);              <span class=\"comment\">% 显示高通滤波后的图像</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"巴特沃斯滤波器\"><a href=\"#巴特沃斯滤波器\" class=\"headerlink\" title=\"巴特沃斯滤波器\"></a>巴特沃斯滤波器</h3><h4 id=\"低通滤波-1\"><a href=\"#低通滤波-1\" class=\"headerlink\" title=\"低通滤波\"></a>低通滤波</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                    <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">f = imread(<span class=\"string\">&#x27;saturn_1.bmp&#x27;</span>); <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">imshow(f);                <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\">f = im2double(f);         <span class=\"comment\">% 转换为双精度浮点（范围[0,1]）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 傅里叶变换并中心化频谱</span></span><br><span class=\"line\">F = fftshift(fft2(f));    <span class=\"comment\">% fft2计算二维DFT，fftshift将零频移至中心</span></span><br><span class=\"line\">[M, N] = <span class=\"built_in\">size</span>(F);         <span class=\"comment\">% 获取频谱尺寸</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 巴特沃斯滤波器参数</span></span><br><span class=\"line\">n = <span class=\"number\">3</span>;                    <span class=\"comment\">% 滤波器阶数（控制过渡带陡峭程度）</span></span><br><span class=\"line\">D0 = <span class=\"number\">40</span>;                  <span class=\"comment\">% 截止频率（半径阈值）</span></span><br><span class=\"line\">u0 = <span class=\"built_in\">floor</span>(M/<span class=\"number\">2</span>);          <span class=\"comment\">% 频谱中心行坐标</span></span><br><span class=\"line\">v0 = <span class=\"built_in\">floor</span>(N/<span class=\"number\">2</span>);          <span class=\"comment\">% 频谱中心列坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 遍历频谱，生成巴特沃斯滤波器并应用</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> u = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        D = <span class=\"built_in\">sqrt</span>((u-u0)^<span class=\"number\">2</span> + (v-v0)^<span class=\"number\">2</span>); <span class=\"comment\">% 计算(u,v)到中心的距离</span></span><br><span class=\"line\">        H = <span class=\"number\">1</span> / (<span class=\"number\">1</span> + (D/D0)^(<span class=\"number\">2</span>*n));    <span class=\"comment\">% 巴特沃斯传递函数</span></span><br><span class=\"line\">        G(u,v) = H * F(u,v);           <span class=\"comment\">% 频域滤波</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 反变换回空间域</span></span><br><span class=\"line\">g = ifft2(ifftshift(G));  <span class=\"comment\">% 逆中心化后逆傅里叶变换</span></span><br><span class=\"line\">g = im2uint8(<span class=\"built_in\">real</span>(g));    <span class=\"comment\">% 取实部并转换为8位图像</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(g);        <span class=\"comment\">% 显示滤波结果</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>巴特沃斯低通滤波器解析（公式整理）</strong></p>\n<p><strong>传递函数</strong></p>\n<p>巴特沃斯低通滤波器的频率响应函数为：<br>$$<br>H(u,v) &#x3D; \\frac{1}{1 + \\left( \\frac{D(u,v)}{D_0} \\right)^{2n}}<br>$$</p>\n<ul>\n<li><p>$D(u,v)$：频率点 $(u,v)$ 到频谱中心的欧氏距离<br>$$<br>D(u,v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}<br>$$</p>\n</li>\n<li><p>$D_0$：截止频率（控制保留低频的范围）</p>\n</li>\n<li><p>$n$：滤波器阶数（控制过渡带的陡峭程度）</p>\n</li>\n</ul>\n<p><strong>特点比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>滤波器类型</th>\n<th>截止特性</th>\n<th>过渡带</th>\n<th>是否振铃</th>\n<th>应用效果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>理想低通</td>\n<td>硬截止</td>\n<td>无</td>\n<td>明显振铃</td>\n<td>强模糊但易产生伪影</td>\n</tr>\n<tr>\n<td>巴特沃斯低通</td>\n<td>平滑过渡</td>\n<td>可调（通过n）</td>\n<td>减少振铃</td>\n<td>过渡自然，常用于图像模糊</td>\n</tr>\n</tbody></table>\n<h4 id=\"高通滤波-1\"><a href=\"#高通滤波-1\" class=\"headerlink\" title=\"高通滤波\"></a>高通滤波</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                         <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">f = imread(<span class=\"string\">&#x27;saturn_1.bmp&#x27;</span>);    <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">imshow(f); title(<span class=\"string\">&#x27;原始图像&#x27;</span>); <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\">f = im2double(f);              <span class=\"comment\">% 转换为双精度浮点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 傅里叶变换并中心化频谱</span></span><br><span class=\"line\">F = fftshift(fft2(f));         </span><br><span class=\"line\">[M, N] = <span class=\"built_in\">size</span>(F);              <span class=\"comment\">% 获取频谱尺寸</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 巴特沃斯高通滤波器参数</span></span><br><span class=\"line\">n = <span class=\"number\">3</span>;                         <span class=\"comment\">% 阶数</span></span><br><span class=\"line\">D0 = <span class=\"number\">20</span>;                       <span class=\"comment\">% 截止频率</span></span><br><span class=\"line\">u0 = <span class=\"built_in\">floor</span>(M/<span class=\"number\">2</span>);              </span><br><span class=\"line\">v0 = <span class=\"built_in\">floor</span>(N/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 初始化滤波器输出矩阵</span></span><br><span class=\"line\">G = <span class=\"built_in\">zeros</span>(M, N);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 遍历频谱，生成高通滤波器并应用</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> u = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        D = <span class=\"built_in\">sqrt</span>((u - u0)^<span class=\"number\">2</span> + (v - v0)^<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> D == <span class=\"number\">0</span></span><br><span class=\"line\">            H = <span class=\"number\">0</span>; <span class=\"comment\">% 防止除以0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            H = <span class=\"number\">1</span> / (<span class=\"number\">1</span> + (D0 / D)^(<span class=\"number\">2</span> * n));  <span class=\"comment\">% 巴特沃斯高通传递函数</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        G(u,v) = H * F(u,v);  <span class=\"comment\">% 频域滤波</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 反傅里叶变换回空间域</span></span><br><span class=\"line\">g = <span class=\"built_in\">real</span>(ifft2(ifftshift(G)));</span><br><span class=\"line\">g = im2uint8(g);              <span class=\"comment\">% 转换为8位图像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(g); title(<span class=\"string\">&#x27;巴特沃斯高通滤波结果 (D0 = 20, n = 3)&#x27;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>巴特沃斯高通滤波器（Butterworth Highpass Filter, BHPF）</strong></p>\n<p><strong>传递函数</strong></p>\n<p>对于图像频域中每个频率点 $(u,v)$，其传递函数为：<br>$$<br>H(u,v) &#x3D; \\frac{1}{1 + \\left(\\frac{D_0}{D(u,v)}\\right)^{2n}} &#x3D; 1 - \\frac{1}{1 + \\left(\\frac{D(u,v)}{D_0}\\right)^{2n}}<br>$$<br>其中：</p>\n<ul>\n<li>$D(u,v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}$：频率点 $(u,v)$ 到频谱中心的欧氏距离；</li>\n<li>$D_0$：<strong>截止频率</strong>，控制滤波器的阻断范围；</li>\n<li>$n$：<strong>阶数</strong>，控制滤波器过渡带的陡峭程度；</li>\n<li>$H(u,v)$：传递函数值（频率响应），表示该频率是否通过。</li>\n</ul>\n<p><strong>特点比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>滤波器类型</th>\n<th>传递函数形状</th>\n<th>振铃效应</th>\n<th>控制参数</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>理想高通（IHPF）</strong></td>\n<td>二值阶跃函数（硬截断）</td>\n<td>严重</td>\n<td>截止频率 $D_0$</td>\n<td>教学、理论分析</td>\n</tr>\n<tr>\n<td><strong>巴特沃斯高通（BHPF）</strong></td>\n<td>平滑过渡（可调阶数）</td>\n<td>较轻微</td>\n<td>$D_0$、阶数 $n$</td>\n<td>通用图像锐化、纹理增强</td>\n</tr>\n<tr>\n<td><strong>高斯高通（GHPF）</strong></td>\n<td>指数平滑衰减函数</td>\n<td>无</td>\n<td>截止频率 $D_0$</td>\n<td>医学图像、工业检测</td>\n</tr>\n</tbody></table>\n<h2 id=\"彩色图像增强\"><a href=\"#彩色图像增强\" class=\"headerlink\" title=\"彩色图像增强\"></a>彩色图像增强</h2><h3 id=\"伪彩色图像增强\"><a href=\"#伪彩色图像增强\" class=\"headerlink\" title=\"伪彩色图像增强\"></a>伪彩色图像增强</h3><p>将一幅灰度图转换成一幅彩色图像</p>\n<p><strong>简单处理：</strong></p>\n<p>将灰度值分为两个区间</p>\n<p><strong>实例</strong></p>\n<p>灰度范围$[0-127]$赋予蓝色$[0,0,255]$</p>\n<p>灰度范围$[128-255]$赋予红色$[255,0,0]$</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;                    <span class=\"comment\">% 清空工作区变量</span></span><br><span class=\"line\">X = imread(<span class=\"string\">&#x27;cat.bmp&#x27;</span>);    <span class=\"comment\">% 读取图像（注：原图为彩色，但代码按灰度处理）</span></span><br><span class=\"line\">imshow(X);                <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\">[M, N] = <span class=\"built_in\">size</span>(X);         <span class=\"comment\">% 获取图像尺寸（仅获取前两维，可能存在问题）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 遍历每个像素，根据灰度值分配颜色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        <span class=\"keyword\">if</span> X(<span class=\"built_in\">i</span>, <span class=\"built_in\">j</span>) &lt; <span class=\"number\">128</span></span><br><span class=\"line\">            Y(<span class=\"built_in\">i</span>, <span class=\"built_in\">j</span>, <span class=\"number\">1</span>:<span class=\"number\">3</span>) = [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">255</span>];  <span class=\"comment\">% 蓝色（低灰度）</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            Y(<span class=\"built_in\">i</span>, <span class=\"built_in\">j</span>, <span class=\"number\">1</span>:<span class=\"number\">3</span>) = [<span class=\"number\">255</span> <span class=\"number\">0</span> <span class=\"number\">0</span>];   <span class=\"comment\">% 红色（高灰度）</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(Y);        <span class=\"comment\">% 显示处理后的图像</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>推广处理：</strong></p>\n<p>把灰度值分割成多个区间</p>\n<h4 id=\"热金属编码\"><a href=\"#热金属编码\" class=\"headerlink\" title=\"热金属编码\"></a><strong>热金属编码</strong></h4><p>灰度范围$[1-63]$赋予蓝色$[0,0,255]$</p>\n<p>灰度范围$[64-127]$赋予紫色$[200,0,200]$</p>\n<p>灰度范围$[128-191]$赋予桔黄色$[255,150,0]$</p>\n<p>灰度范围$[192-254]$赋予黄色$[255,255,0]$</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;</span><br><span class=\"line\">X = imread(<span class=\"string\">&#x27;cat.bmp&#x27;</span>);  <span class=\"comment\">% 读取图像（假设为灰度图）</span></span><br><span class=\"line\">imshow(X);              <span class=\"comment\">% 显示原始图像</span></span><br><span class=\"line\"></span><br><span class=\"line\">Y = X / <span class=\"number\">64</span>;            <span class=\"comment\">% 量化：将像素值压缩到0~3范围（256/64=4级）</span></span><br><span class=\"line\">[M,N] = <span class=\"built_in\">size</span>(Y);       <span class=\"comment\">% 获取图像尺寸</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> Y(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)   <span class=\"comment\">% 根据量化值分配颜色</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,<span class=\"number\">1</span>:<span class=\"number\">3</span>) = [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">255</span>];     <span class=\"comment\">% 蓝色</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,<span class=\"number\">1</span>:<span class=\"number\">3</span>) = [<span class=\"number\">200</span> <span class=\"number\">0</span> <span class=\"number\">200</span>];   <span class=\"comment\">% 紫色</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,<span class=\"number\">1</span>:<span class=\"number\">3</span>) = [<span class=\"number\">255</span> <span class=\"number\">150</span> <span class=\"number\">0</span>];   <span class=\"comment\">% 橙色</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,:) = [<span class=\"number\">255</span> <span class=\"number\">255</span> <span class=\"number\">0</span>]; <span class=\"comment\">% 补充黄色</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">% 注：代码未显示Y1的显示部分（应有 imshow(Y1)）</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"彩虹编码\"><a href=\"#彩虹编码\" class=\"headerlink\" title=\"彩虹编码\"></a><strong>彩虹编码</strong></h4><p>灰度范围$[0-63]$赋予蓝色$[0,0,255]$</p>\n<p>灰度范围$[64-127]$赋予绿色$[0,255,0]$</p>\n<p>灰度范围$[128-191]$赋予红色$[255,0,0]$</p>\n<p>灰度范围$[192-254]$赋予品红色$[255,0,255]$</p>\n<p><strong>代码实现</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;</span><br><span class=\"line\">X = imread(<span class=\"string\">&#x27;cat.bmp&#x27;</span>);    <span class=\"comment\">% 读取灰度图像</span></span><br><span class=\"line\">imshow(X); title(<span class=\"string\">&#x27;原始图像&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% Step 1: 灰度值量化为 0~3（分为4段）</span></span><br><span class=\"line\">Y = <span class=\"built_in\">floor</span>(double(X) / <span class=\"number\">64</span>);     <span class=\"comment\">% 将像素值分段：0=[0,63], 1=[64,127], etc.</span></span><br><span class=\"line\">Y(Y == <span class=\"number\">4</span>) = <span class=\"number\">3</span>;                 <span class=\"comment\">% 处理255时 floor(255/64)=3.984→4，强制归入第4类</span></span><br><span class=\"line\"></span><br><span class=\"line\">[M, N] = <span class=\"built_in\">size</span>(Y);</span><br><span class=\"line\">Y1 = <span class=\"built_in\">zeros</span>(M, N, <span class=\"number\">3</span>, <span class=\"string\">&#x27;uint8&#x27;</span>);  <span class=\"comment\">% 初始化RGB图像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% Step 2: 色彩映射</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> Y(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,:) = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>];     <span class=\"comment\">% 蓝色：0–63</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,:) = [<span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>];     <span class=\"comment\">% 绿色：64–127</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,:) = [<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];     <span class=\"comment\">% 红色：128–191</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span></span><br><span class=\"line\">                Y1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>,:) = [<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>];   <span class=\"comment\">% 品红色：192–254（含255）</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% Step 3: 显示伪彩色图像</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(Y1); title(<span class=\"string\">&#x27;伪彩色映射图像&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"假彩色图像增强\"><a href=\"#假彩色图像增强\" class=\"headerlink\" title=\"假彩色图像增强\"></a>假彩色图像增强</h3><p>将同一幅灰度图送入红、绿、蓝三个变换器，在三个变换器中对同一灰度实施不同变化，使三个变换器输出不同。将三个不同输出合成某一种彩色图像。</p>\n<p>变换器算法的线性方程</p>\n<p>红色通道 $R$<br>$$<br>R(f) &#x3D;<br>\\begin{cases}<br>0, &amp; 0 \\le f &lt; \\dfrac{L}{2} \\<br>4f - 2L, &amp; \\dfrac{L}{2} \\le f &lt; \\dfrac{3L}{4} \\<br>L, &amp; \\dfrac{3L}{4} \\le f \\le L<br>\\end{cases}<br>$$<br>绿色通道 $G$<br>$$<br>G(f) &#x3D;<br>\\begin{cases}<br>4f, &amp; 0 \\le f &lt; \\dfrac{L}{4} \\<br>L, &amp; \\dfrac{L}{4} \\le f &lt; \\dfrac{3L}{4} \\<br>-4f + 4L, &amp; \\dfrac{3L}{4} \\le f \\le L<br>\\end{cases}<br>$$<br>蓝色通道 $B$<br>$$<br>B(f) &#x3D;<br>\\begin{cases}<br>L, &amp; 0 \\le f &lt; \\dfrac{L}{4} \\<br>-4f + 2L, &amp; \\dfrac{L}{4} \\le f &lt; \\dfrac{L}{2} \\<br>0, &amp; \\dfrac{L}{2} \\le f \\le L<br>\\end{cases}<br>$$<br>代码实现</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear</span><br><span class=\"line\">f = imread(<span class=\"string\">&#x27;rice.bmp&#x27;</span>);  <span class=\"comment\">% 读取图像（应为灰度图）</span></span><br><span class=\"line\">imshow(f);</span><br><span class=\"line\">[M,N] = <span class=\"built_in\">size</span>(f); L = <span class=\"number\">255</span>;</span><br><span class=\"line\">f = double(f);           <span class=\"comment\">% 转换为双精度</span></span><br><span class=\"line\">f1 = <span class=\"built_in\">floor</span>(f/<span class=\"number\">64</span>);        <span class=\"comment\">% 4级量化（0-3）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 初始化RGB通道</span></span><br><span class=\"line\">R = f1; G = f1; B = f1;  <span class=\"comment\">% 错误：应用zeros(M,N)初始化（ppt代码）</span></span><br><span class=\"line\">R = <span class=\"built_in\">zeros</span>(M,N); G = <span class=\"built_in\">zeros</span>(M,N); B = <span class=\"built_in\">zeros</span>(M,N); <span class=\"comment\">% 正确初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span>:M</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span>:N</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> f1(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)   <span class=\"comment\">% 根据量化值分配颜色</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span></span><br><span class=\"line\">                R(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">0</span>; G(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">4</span>*f(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>); B(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=L;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span></span><br><span class=\"line\">                R(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">0</span>; G(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=L; B(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">-4</span>*f(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)+<span class=\"number\">2</span>*L; </span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span></span><br><span class=\"line\">                R(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">4</span>*f(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)<span class=\"number\">-2</span>*L; G(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=L; B(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span></span><br><span class=\"line\">                R(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=L; G(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">-4</span>*f(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)+<span class=\"number\">4</span>*L; B(<span class=\"built_in\">i</span>,<span class=\"built_in\">j</span>)=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">g(:,:,<span class=\"number\">1</span>) = R; g(:,:,<span class=\"number\">2</span>) = G; g(:,:,<span class=\"number\">3</span>) = B; <span class=\"comment\">% 合并通道</span></span><br><span class=\"line\">g = uint8(g);</span><br><span class=\"line\"><span class=\"built_in\">figure</span>, imshow(g);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"真彩色图像增强\"><a href=\"#真彩色图像增强\" class=\"headerlink\" title=\"真彩色图像增强\"></a>真彩色图像增强</h3><p>将真彩色图像RGB分开，针对各分量分别进行增强处理，然后合并为新的真彩色图像。</p>\n<h1 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h1><h2 id=\"图像压缩和冗余\"><a href=\"#图像压缩和冗余\" class=\"headerlink\" title=\"图像压缩和冗余\"></a>图像压缩和冗余</h2><p>压缩类型：有损、无损</p>\n<p>冗余类型：像素冗余、编码冗余、视觉心理冗余</p>\n<p>像素冗余—-&gt;压缩方法：行程编码（无损，可逆）</p>\n<p>实例</p>\n<p>0….0（15个）2….2（11个）1….1（30个）4….4（70个）0….0（18个）</p>\n<p>行程编码：</p>\n<p>15{0}11{2}30{1}70{4}18{0}</p>\n<p>编码冗余—-&gt;哈夫曼编码（可逆）</p>\n<p>视觉心理冗余—–&gt;（有损，不可逆）</p>\n<p><strong>图像编码解码过程：</strong></p>\n<p><strong>原始图像—-&gt;压缩编码器—–&gt;编码结果——&gt;存储&#x2F;传输——&gt;压缩解码器—-&gt;解码图像</strong></p>\n<p>注：解码图像与原始图像相同（无损压缩）&#x2F;不相同（有损压缩）</p>\n<p><strong>压缩编码器模型（3个独立操作）：</strong></p>\n<p><strong>输入原始图像—&gt;映射器—-&gt;量化器—-&gt;符号编码器—-&gt;生成编码</strong></p>\n<p>映射器：减少像素冗余，使用行程编码（无损）</p>\n<p>量化器：减少视觉心理冗余（仅用于有损压缩）</p>\n<p>符号编码器：减少编码冗余，使用哈夫曼编码（无损）</p>\n<p><strong>压缩解码器模型（2个独立操作）：</strong></p>\n<p><strong>输入编码—&gt;反符号解码器—–&gt;反映射器—–&gt;输出解码图像</strong></p>\n<p><strong>注：整个过程与编码模型相反，由于量化是不可逆操作，所以没有“反量化器”</strong></p>\n<h2 id=\"行程编码\"><a href=\"#行程编码\" class=\"headerlink\" title=\"行程编码\"></a>行程编码</h2><p>行程编码（Run-Length Encoding, RLE）是一种<strong>无损压缩方法</strong>，适用于<strong>重复值较多</strong>的图像（如黑白图、二值图或简单灰度图）。下面是它的<strong>压缩前与压缩后大小的计算方法</strong>详解：</p>\n<p> <strong>一、压缩前大小（未压缩图像）</strong></p>\n<p>压缩前的数据通常是图像的原始像素值，每个像素占用固定的字节。</p>\n<p><strong>计算公式：</strong><br>$$<br>\\text{未压缩大小（字节）} &#x3D; \\text{图像总像素数} \\times \\text{每像素字节数}<br>$$<br><strong>说明：</strong></p>\n<ul>\n<li>对于 <strong>8位灰度图</strong>，每个像素占 <strong>1字节（8bits）</strong>；</li>\n<li>若是 <strong>RGB 彩色图像</strong>，每个像素占 <strong>3字节（24bits）</strong>（R, G, B 各1字节）；</li>\n<li>图像总像素数 &#x3D; 行数 × 列数</li>\n</ul>\n<p><strong>二、压缩后大小（RLE）</strong></p>\n<p>行程编码将<strong>连续相同的像素值</strong>用“值 + 次数”对来表示，因此压缩后只记录：<br>$$<br>\\text{压缩后数据} &#x3D; \\sum_{i&#x3D;1}^{k} \\left(\\text{像素值} + \\text{重复次数}\\right)<br>$$<br>其中，$k$ 是图像中<strong>不同的连续值段数</strong>。</p>\n<p><strong>计算公式：</strong><br>$$<br>\\text{压缩后大小（字节）} &#x3D; k \\times (\\text{每个值的字节数} + \\text{每个次数的字节数})<br>$$</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通常，每个像素值和重复次数都用 <strong>1 字节</strong> 表示（即 8 位图像中）</p></blockquote>\n<p><strong>注意：1个字节8bit</strong></p>\n<p><strong>实例（这里是按bit算的）</strong></p>\n<p>压缩前：$aaaabbbccdeeeeefffffff$</p>\n<p>$22*8&#x3D;176bits$</p>\n<p>压缩后：$4a3b2c1d5e7f$</p>\n<p>$6*（3+8）&#x3D;66bits$</p>\n<p><strong>代码实现（压缩部分）</strong></p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear all;</span><br><span class=\"line\">I1 = imread(<span class=\"string\">&#x27;lena.bmp&#x27;</span>);       <span class=\"comment\">% 读取图像</span></span><br><span class=\"line\">I2 = im2bw(I1, <span class=\"number\">0.5</span>);          <span class=\"comment\">% 二值化（阈值0.5）</span></span><br><span class=\"line\">I3 = I2(:);                   <span class=\"comment\">% 将图像展开为一维列向量</span></span><br><span class=\"line\">I3len = <span class=\"built_in\">length</span>(I3);           <span class=\"comment\">% 获取原始数据长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 游程编码核心算法</span></span><br><span class=\"line\"><span class=\"built_in\">j</span> = <span class=\"number\">1</span>; n = <span class=\"number\">1</span>;                 <span class=\"comment\">% j: 游程序号，n: 当前游程长度</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> z = <span class=\"number\">1</span>:(I3len<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> I3(z) == I3(z+<span class=\"number\">1</span>)       <span class=\"comment\">% 当前像素与下一像素相同</span></span><br><span class=\"line\">        n = n + <span class=\"number\">1</span>;            <span class=\"comment\">% 游程长度+1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pixel(<span class=\"built_in\">j</span>) = I3(z);     <span class=\"comment\">% 记录当前游程的像素值（0或1）</span></span><br><span class=\"line\">        numpixel(<span class=\"built_in\">j</span>) = n;      <span class=\"comment\">% 记录当前游程长度</span></span><br><span class=\"line\">        <span class=\"built_in\">j</span> = <span class=\"built_in\">j</span> + <span class=\"number\">1</span>;            <span class=\"comment\">% 移动到下一个游程</span></span><br><span class=\"line\">        n = <span class=\"number\">1</span>;                <span class=\"comment\">% 重置游程长度计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">% 处理最后一个游程</span></span><br><span class=\"line\">pixel(<span class=\"built_in\">j</span>) = I3(z+<span class=\"number\">1</span>);           <span class=\"comment\">% 记录最后一个像素值</span></span><br><span class=\"line\">numpixel(<span class=\"built_in\">j</span>) = n;              <span class=\"comment\">% 记录最后一个游程长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算压缩比和输出结果</span></span><br><span class=\"line\">pixel_len = <span class=\"built_in\">length</span>(pixel);    <span class=\"comment\">% 压缩后的游程总数</span></span><br><span class=\"line\">CR = I3len / (pixel_len * <span class=\"number\">2</span>); <span class=\"comment\">% 压缩比公式（注：分母为游程对数量×2）</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>(<span class=\"string\">&#x27;压缩比：&#x27;</span>); <span class=\"built_in\">disp</span>(CR);</span><br><span class=\"line\"><span class=\"built_in\">disp</span>(<span class=\"string\">&#x27;原图像数据的长度：&#x27;</span>); <span class=\"built_in\">disp</span>(I3len);</span><br><span class=\"line\"><span class=\"built_in\">disp</span>(<span class=\"string\">&#x27;压缩后图像数据的长度：&#x27;</span>); <span class=\"built_in\">disp</span>(pixel_len);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h2><p>哈夫曼编码基本步骤</p>\n<ol>\n<li><p>统计字符频率</p>\n</li>\n<li><p>构建哈夫曼树</p>\n<ul>\n<li>把每个字符看作一个“节点”，频率作为“权值”。</li>\n<li>每次从节点集中<strong>选两个最小的</strong>，合并成一个新的父节点，其权值为两个子节点权值之和。</li>\n<li>重复这个过程，直到只剩一个节点（根节点）。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始：</span><br><span class=\"line\"><span class=\"selector-tag\">a</span>(<span class=\"number\">3</span>), <span class=\"selector-tag\">b</span>(<span class=\"number\">2</span>), <span class=\"built_in\">c</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">合并最小两个：<span class=\"selector-tag\">b</span>(<span class=\"number\">2</span>) + <span class=\"built_in\">c</span>(<span class=\"number\">1</span>) → 新节点<span class=\"built_in\">bc</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">剩下：<span class=\"selector-tag\">a</span>(<span class=\"number\">3</span>), <span class=\"built_in\">bc</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">再合并：<span class=\"selector-tag\">a</span>(<span class=\"number\">3</span>) + <span class=\"built_in\">bc</span>(<span class=\"number\">3</span>) → 根节点<span class=\"built_in\">abc</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   abc(<span class=\"number\">6</span>)</span><br><span class=\"line\">  /     \\</span><br><span class=\"line\"><span class=\"selector-tag\">a</span>(<span class=\"number\">3</span>)   bc(<span class=\"number\">3</span>)</span><br><span class=\"line\">      /    \\</span><br><span class=\"line\">    c(<span class=\"number\">1</span>)   <span class=\"selector-tag\">b</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>哈夫曼编码中，将较大频率放左边还是右边，其实<strong>没有影响最终的压缩效率</strong>，但会<strong>影响具体的编码结果（0 和 1 的分配）</strong>。</p></blockquote>\n<p><strong>占用空间的计算</strong></p>\n<p>每个字符：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符频率 × 它的码长（单位：位）</span><br></pre></td></tr></table></figure></blockquote>\n<p>总压缩后大小（单位：位）：</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">∑（每个字符的频率 × 对应码长）</span><br></pre></td></tr></table></figure></blockquote>\n<p><strong>实例</strong></p>\n<p>字符串 <code>&quot;aaaabbbccd&quot;</code></p>\n<p>统计频率：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a: 4</span><br><span class=\"line\">b: 3</span><br><span class=\"line\">c: 2</span><br><span class=\"line\">d: 1</span><br></pre></td></tr></table></figure>\n\n<p>构建哈夫曼树（略），得到编码可能如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a: 0     （频率高 → 路径短）</span><br><span class=\"line\">b: 10</span><br><span class=\"line\">c: 110</span><br><span class=\"line\">d: 111</span><br></pre></td></tr></table></figure>\n\n<p>对应的码长：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a: 1 位</span><br><span class=\"line\">b: 2 位</span><br><span class=\"line\">c: 3 位</span><br><span class=\"line\">d: 3 位</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频率</th>\n<th>码长</th>\n<th>占用位数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>a</td>\n<td>4</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>b</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n</tr>\n<tr>\n<td>c</td>\n<td>2</td>\n<td>3</td>\n<td>6</td>\n</tr>\n<tr>\n<td>d</td>\n<td>1</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td><strong>总计</strong></td>\n<td></td>\n<td></td>\n<td><strong>19 位</strong></td>\n</tr>\n</tbody></table>\n<p>原始数据有 10 个字符，若是<strong>定长编码</strong>（每个字符都用 8 bit 存储）：</p>\n<blockquote>\n<p>原始大小 &#x3D; <code>10 × 8 = 80 位</code></p></blockquote>\n<h1 id=\"七\"><a href=\"#七\" class=\"headerlink\" title=\"七\"></a>七</h1><h2 id=\"膨胀\"><a href=\"#膨胀\" class=\"headerlink\" title=\"膨胀\"></a>膨胀</h2><p>膨胀（<strong>Dilation</strong>）是<strong>图像形态学处理</strong>中常用的一种操作，主要用于<strong>扩展图像中目标（前景）区域的边界</strong>，让物体“变大”。</p>\n<p><strong>一、基本概念</strong></p>\n<ul>\n<li>输入：<strong>二值图像</strong>（通常是0表示背景，1表示前景）</li>\n<li>工具：<strong>结构元素（SE）</strong>，比如一个小的方形、圆形、十字形模板</li>\n<li>目的：将结构元素“套”在图像上，检查是否与前景接触，决定是否扩展</li>\n</ul>\n<p> <strong>二、膨胀的定义（数学）</strong></p>\n<p>设图像为集合 $A$，结构元素为 $B$，则膨胀定义为：<br>$$<br>A \\oplus B &#x3D; { z \\mid (\\hat{B})_z \\cap A \\neq \\emptyset }<br>$$<br>直观理解：</p>\n<ul>\n<li>将结构元素的“中心”移动到每个前景像素位置</li>\n<li>把结构元素覆盖到图像中，把结构元素所有接触的像素设为前景</li>\n</ul>\n<p> <strong>三、直观理解</strong></p>\n<p>**前景是白色（1），背景是黑色（0）**时：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>若某点周围有<strong>一个前景像素</strong>，结构元素就会<strong>把它扩展成一片前景</strong>。</p></blockquote>\n<p>所以：</p>\n<ul>\n<li>前景边缘会向外“膨胀”</li>\n<li>小黑洞、裂缝会被填补</li>\n</ul>\n<h2 id=\"腐蚀\"><a href=\"#腐蚀\" class=\"headerlink\" title=\"腐蚀\"></a>腐蚀</h2><p>腐蚀运算（<strong>Erosion</strong>）是<strong>图像形态学</strong>中的一种基本操作，常用于去除小的白色区域、分离连接物体、缩小图像中前景区域（通常是白色）的边界。</p>\n<p> <strong>一、基本概念</strong></p>\n<p>腐蚀可以理解为：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>用结构元素去“试探”图像中每一个位置，只有当结构元素“完全贴合”目标区域（即前景）时，该位置才保留为前景。否则，就腐蚀成背景。</strong></p></blockquote>\n<p><strong>二、形式定义</strong></p>\n<p>设：</p>\n<ul>\n<li>原始图像为 $A$（通常是二值图像）</li>\n<li>结构元素为 $B$</li>\n</ul>\n<p><strong>腐蚀运算</strong>记作：<br>$$<br>A \\ominus B<br>$$<br>数学定义是：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>腐蚀后图像中，所有点 $z$ 满足结构元素 $B$ 平移到 $z$ 后，仍完全包含于原图像 $A$。</p></blockquote>\n<p><strong>三、操作直觉</strong></p>\n<ul>\n<li>把结构元素中心对齐到图像中每一个前景点。</li>\n<li><strong>如果结构元素完全落在图像的白色区域内</strong>（前景），则中心点保留为白色。</li>\n<li>否则，中心点变为黑色（背景）。</li>\n</ul>\n<p><strong>四、腐蚀的效果</strong></p>\n<table>\n<thead>\n<tr>\n<th>原图前景</th>\n<th>腐蚀后效果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>白色区域</td>\n<td>被<strong>收缩、变小、变细</strong></td>\n</tr>\n<tr>\n<td>小的白点</td>\n<td>可能被完全腐蚀掉</td>\n</tr>\n<tr>\n<td>空洞边界</td>\n<td>会向内收缩，缩小孔洞</td>\n</tr>\n</tbody></table>\n<h2 id=\"开运算\"><a href=\"#开运算\" class=\"headerlink\" title=\"开运算\"></a>开运算</h2><p>开运算（<strong>Opening</strong>）是图像形态学中的一种复合操作，表示为：<br>$$<br>A \\circ B &#x3D; (A \\ominus B) \\oplus B<br>$$<br>其中：</p>\n<ul>\n<li>$A$：原始图像（二值图）</li>\n<li>$B$：结构元素</li>\n<li>$\\ominus$：腐蚀运算</li>\n<li>$\\oplus$：膨胀运算</li>\n</ul>\n<p><strong>什么是开运算</strong></p>\n<p>开运算 &#x3D; <strong>先腐蚀，后膨胀</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>其本质是：<strong>去除小的前景区域（白色区域）或细小突出部分，同时保留整体轮廓形状不变的大物体。</strong></p></blockquote>\n<p><strong>操作直觉</strong></p>\n<ol>\n<li><strong>腐蚀</strong>：去掉图像边缘、小的前景点、细小突出。</li>\n<li><strong>膨胀</strong>：恢复腐蚀后被缩小的主要结构。</li>\n</ol>\n<p>这样，<strong>小噪点不会恢复，而大结构会恢复原形</strong>，所以开运算<strong>非常适合去除小物体和突出部分</strong>。</p>\n<p><strong>开运算的效果</strong></p>\n<table>\n<thead>\n<tr>\n<th>作用</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>去除小白点</td>\n<td>噪声被腐蚀掉，无法恢复</td>\n</tr>\n<tr>\n<td>平滑前景物体边界</td>\n<td>去除尖角、毛刺</td>\n</tr>\n<tr>\n<td>分离粘连物体</td>\n<td>若连接细小部分被腐蚀，则被断开</td>\n</tr>\n<tr>\n<td>不改变主前景结构</td>\n<td>大物体轮廓基本保留</td>\n</tr>\n</tbody></table>\n<h2 id=\"闭运算\"><a href=\"#闭运算\" class=\"headerlink\" title=\"闭运算\"></a>闭运算</h2><p>闭运算（<strong>Closing</strong>）是形态学图像处理中的一种基本操作，它是<strong>膨胀后腐蚀</strong>的复合操作，记作：<br>$$<br>A \\bullet B &#x3D; (A \\oplus B) \\ominus B<br>$$<br>其中：</p>\n<ul>\n<li>$A$：原始图像（二值图像，白色代表前景）</li>\n<li>$B$：结构元素（通常为小圆、方块、线段等）</li>\n<li>$\\oplus$：膨胀</li>\n<li>$\\ominus$：腐蚀</li>\n</ul>\n<p> <strong>闭运算做了什么</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>闭运算 &#x3D; <strong>先膨胀，再腐蚀</strong></p></blockquote>\n<p>它的目标是：</p>\n<p>  <strong>填补前景中的小孔洞、缝隙</strong><br>  <strong>连接相近但断裂的白色区域（前景）</strong><br>  <strong>平滑物体边界，去除黑色小凹陷</strong></p>\n<p> <strong>操作流程解释</strong></p>\n<ul>\n<li><strong>膨胀</strong>：前景区域变大，填补小洞、连接细缝。</li>\n<li><strong>腐蚀</strong>：把膨胀带来的外扩减掉，只保留原本连接和填补的部分。</li>\n</ul>\n<p><strong>闭运算的作用总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>填小黑洞</td>\n<td>内部的小黑洞会被填满</td>\n</tr>\n<tr>\n<td>连接细线断裂</td>\n<td>若两白色区域之间缝隙小，能连起来</td>\n</tr>\n<tr>\n<td>平滑边缘</td>\n<td>去除凹陷区域</td>\n</tr>\n<tr>\n<td>保留整体形状</td>\n<td>不会大范围改变图像结构</td>\n</tr>\n</tbody></table>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><table>\n<thead>\n<tr>\n<th>运算类型</th>\n<th>对二值图作用（前景为白）</th>\n<th>对灰度图作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>腐蚀</strong></td>\n<td>收缩白色区域，去除小白点，细线消失</td>\n<td>凹陷更明显，整体暗化，边缘细节变清晰</td>\n</tr>\n<tr>\n<td><strong>膨胀</strong></td>\n<td>扩张白色区域，连接断裂，填补细缝、孔洞</td>\n<td>凸起更明显，整体变亮，模糊小凹陷</td>\n</tr>\n<tr>\n<td><strong>开运算</strong></td>\n<td>先腐蚀后膨胀，去除小白噪声，断开细白线</td>\n<td>平滑亮区域边缘，去除小高亮区（如亮斑、噪声）</td>\n</tr>\n<tr>\n<td><strong>闭运算</strong></td>\n<td>先膨胀后腐蚀，填补小黑洞，连接接近白区域</td>\n<td>平滑暗区域边缘，填暗斑，连接中断结构</td>\n</tr>\n</tbody></table>\n<h1 id=\"八\"><a href=\"#八\" class=\"headerlink\" title=\"八\"></a>八</h1><h2 id=\"边缘检测\"><a href=\"#边缘检测\" class=\"headerlink\" title=\"边缘检测\"></a>边缘检测</h2><h3 id=\"正交梯度算子法\"><a href=\"#正交梯度算子法\" class=\"headerlink\" title=\"正交梯度算子法\"></a>正交梯度算子法</h3><p><strong>基本概念</strong></p>\n<p>正交梯度算子法是一种典型的<strong>边缘检测方法</strong>，属于<strong>基于一阶导数</strong>的图像处理技术。</p>\n<ul>\n<li>它通过计算图像在水平方向和垂直方向的灰度变化（即梯度）来检测边缘。</li>\n<li>在边缘处，图像灰度变化剧烈，梯度幅值较大，因此可以通过梯度检测边缘。</li>\n</ul>\n<p><strong>数学定义</strong></p>\n<p>(1) 梯度向量定义：</p>\n<h1 id=\"给定图像灰度函数-f-x-y-，其梯度为：-nabla-f-x-y-begin-bmatrix-G-x-G-y-end-bmatrix\"><a href=\"#给定图像灰度函数-f-x-y-，其梯度为：-nabla-f-x-y-begin-bmatrix-G-x-G-y-end-bmatrix\" class=\"headerlink\" title=\"给定图像灰度函数 $f(x, y)$，其梯度为：$$\\nabla f(x, y) &#x3D;\\begin{bmatrix}G_x \\G_y\\end{bmatrix}\"></a>给定图像灰度函数 $f(x, y)$，其梯度为：<br>$$<br>\\nabla f(x, y) &#x3D;<br>\\begin{bmatrix}<br>G_x \\<br>G_y<br>\\end{bmatrix}</h1><p>\\begin{bmatrix}<br>\\frac{\\partial f}{\\partial x} \\<br>\\frac{\\partial f}{\\partial y}<br>\\end{bmatrix}<br>$$</p>\n<ul>\n<li>$G_x$：沿水平方向的灰度变化（横向变化率）</li>\n<li>$G_y$：沿垂直方向的灰度变化（纵向变化率）</li>\n</ul>\n<p>(2) 梯度幅值（Gradient Magnitude）：<br>$$<br>G(x, y) &#x3D; \\sqrt{G_x^2 + G_y^2}<br>$$</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>表示像素处灰度变化的“强度”，即边缘显著程度。</p></blockquote>\n<p>(3) 梯度方向（Gradient Direction）：<br>$$<br>\\varphi(x, y) &#x3D; \\arctan\\left(\\frac{G_y}{G_x}\\right)<br>$$</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>表示灰度变化的“方向”，<strong>与边缘方向垂直</strong>。</p></blockquote>\n<h4 id=\"一阶差分近似梯度法\"><a href=\"#一阶差分近似梯度法\" class=\"headerlink\" title=\"一阶差分近似梯度法\"></a><strong>一阶差分近似梯度法</strong></h4><p>在数字图像处理中，图像是离散的像素点组成的，无法直接使用连续导数公式。<br> 因此，<strong>用一阶差分（finite difference）近似导数</strong>，来表示图像中灰度值的变化。</p>\n<p>这种差分可以反映图像中像素灰度变化的程度——即<strong>边缘检测的核心依据</strong>。</p>\n<p><strong>定义</strong></p>\n<p>设图像为二维离散函数 $f(m,n)$，其中：</p>\n<ul>\n<li>$m$：图像的行（垂直方向）</li>\n<li>$n$：图像的列（水平方向）</li>\n</ul>\n<p><strong>水平方向梯度：</strong><br>$$<br>G_h(m,n) &#x3D; f(m,n) - f(m,n-1)<br>$$<br>表示当前像素与其<strong>左邻像素的灰度差</strong>，反映水平方向的灰度变化。</p>\n<p><strong>垂直方向梯度：</strong><br>$$<br>G_v(m,n) &#x3D; f(m,n) - f(m-1,n)<br>$$<br>表示当前像素与其<strong>上邻像素的灰度差</strong>，反映垂直方向的灰度变化。</p>\n<p>差分可以通过<strong>卷积操作</strong>来实现，用于图像的快速处理。</p>\n<p><strong>水平方向模板 $W_h$：</strong><br>$$<br>W_h &#x3D;<br>\\begin{bmatrix}<br>0 &amp; 0 &amp; 0 \\<br>-1 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0<br>\\end{bmatrix}<br>$$</p>\n<ul>\n<li>相当于对当前像素与其左边像素做差。</li>\n<li>核心位于中间行中：$-1, 1$</li>\n</ul>\n<p><strong>垂直方向模板 $W_v$：</strong><br>$$<br>W_v &#x3D;<br>\\begin{bmatrix}<br>0 &amp; -1 &amp; 0 \\<br>0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0<br>\\end{bmatrix}<br>$$</p>\n<ul>\n<li>相当于对当前像素与其上方像素做差。</li>\n<li>核心位于中间列中：$-1, 1$</li>\n</ul>\n<p>设输入图像为 $f$，则有：</p>\n<ul>\n<li><p><strong>水平梯度图像</strong>：<br>$$<br>G_h &#x3D; f * W_h<br>$$</p>\n</li>\n<li><p><strong>垂直梯度图像</strong>：<br>$$<br>G_v &#x3D; f * W_v<br>$$</p>\n</li>\n</ul>\n<p>其中 $*$ 表示卷积操作。</p>\n<h4 id=\"算子总结\"><a href=\"#算子总结\" class=\"headerlink\" title=\"算子总结\"></a>算子总结</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>名称</th>\n<th>卷积模板</th>\n<th>描述方向</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>正交算子（水平&#x2F;垂直）</td>\n<td><code>1001</code></td>\n<td>垂直方向</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Roberts 算子</td>\n<td>对角</td>\n<td>45°&#x2F;135°方向</td>\n</tr>\n<tr>\n<td>3</td>\n<td>斜着的 <code>1001</code></td>\n<td>斜方向</td>\n<td>类似 Roberts，更简化版</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Sobel 算子</td>\n<td>水平&#x2F;垂直</td>\n<td>考虑邻域加权</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Prewitt 算子</td>\n<td>水平&#x2F;垂直</td>\n<td>类似 Sobel，但不加权</td>\n</tr>\n</tbody></table>\n<h5 id=\"正交梯度算子（差分版-1001）\"><a href=\"#正交梯度算子（差分版-1001）\" class=\"headerlink\" title=\"正交梯度算子（差分版 1001）\"></a><strong>正交梯度算子</strong>（差分版 <code>1001</code>）</h5><p>水平方向（检测上下边缘）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wx = [ <span class=\"number\">0</span>  <span class=\"number\">1</span>  <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"number\">0</span> <span class=\"number\">-1</span>  <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"number\">0</span>  <span class=\"number\">0</span>  <span class=\"number\">0</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>垂直方向（检测左右边缘）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wy = [ <span class=\"number\">0</span>  <span class=\"number\">0</span>  <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"number\">1</span> <span class=\"number\">-1</span>  <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"number\">0</span>  <span class=\"number\">0</span>  <span class=\"number\">0</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>等价于对图像进行一阶差分，称为<strong>正交方向差分模板（Orthogonal Difference）</strong>。</p>\n<h5 id=\"Roberts-算子（经典对角线边缘）\"><a href=\"#Roberts-算子（经典对角线边缘）\" class=\"headerlink\" title=\"Roberts 算子（经典对角线边缘）\"></a><strong>Roberts 算子</strong>（经典对角线边缘）</h5><p>方向1（45°）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R1 = [ <span class=\"number\">-1</span>  <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"number\">0</span>  <span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>方向2（135°）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R2 = [ <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\">       <span class=\"number\">1</span>  <span class=\"number\">0</span> ];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>尺寸：2×2</li>\n<li>用于检测图像的<strong>对角线方向边缘</strong></li>\n<li>响应快但对噪声更敏感</li>\n</ul>\n<h5 id=\"Sobel-算子（常用，带加权）\"><a href=\"#Sobel-算子（常用，带加权）\" class=\"headerlink\" title=\"Sobel 算子（常用，带加权）\"></a><strong>Sobel 算子</strong>（常用，带加权）</h5><p>水平方向（x方向）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sx = [ <span class=\"number\">-1</span>  <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"number\">-2</span>  <span class=\"number\">0</span>  <span class=\"number\">2</span></span><br><span class=\"line\">       <span class=\"number\">-1</span>  <span class=\"number\">0</span>  <span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>垂直方向（y方向）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sy = [ <span class=\"number\">-1</span> <span class=\"number\">-2</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"number\">0</span>  <span class=\"number\">0</span>  <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"number\">1</span>  <span class=\"number\">2</span>  <span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>中心像素权重更高（加权）</strong></li>\n<li>对噪声有一定抑制能力</li>\n<li>常用于梯度边缘检测中计算 Gx 和 Gy</li>\n</ul>\n<h5 id=\"Prewitt-算子（与-Sobel-类似，但不加权）\"><a href=\"#Prewitt-算子（与-Sobel-类似，但不加权）\" class=\"headerlink\" title=\"Prewitt 算子（与 Sobel 类似，但不加权）\"></a><strong>Prewitt 算子</strong>（与 Sobel 类似，但不加权）</h5><p>水平方向（x方向）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Px = [ <span class=\"number\">-1</span>  <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"number\">-1</span>  <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"number\">-1</span>  <span class=\"number\">0</span>  <span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<p>垂直方向（y方向）：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Py = [ <span class=\"number\">-1</span> <span class=\"number\">-1</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"number\">0</span>  <span class=\"number\">0</span>  <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"number\">1</span>  <span class=\"number\">1</span>  <span class=\"number\">1</span> ];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类似 Sobel，但每列权重一致</li>\n<li>更简单，但边缘检测效果略弱于 Sobel</li>\n</ul>\n<h3 id=\"梯度图像\"><a href=\"#梯度图像\" class=\"headerlink\" title=\"梯度图像\"></a>梯度图像</h3><p> 一、梯度图像计算三种方式与对应“距离度量”</p>\n<table>\n<thead>\n<tr>\n<th>梯度幅度计算公式</th>\n<th>数学表达</th>\n<th>对应距离度量</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>欧氏距离</strong></td>\n<td>$G(m,n) &#x3D; \\sqrt{G_h^2 + G_v^2}$</td>\n<td>$D_e$</td>\n<td>精度高、边缘平滑，但<strong>计算慢</strong>（含平方根）</td>\n</tr>\n<tr>\n<td><strong>城市街区距离</strong></td>\n<td>$G(m,n)&#x3D;∥Gh∥+∥Gv∥$</td>\n<td>$D_4$</td>\n<td>计算简单，适合实时处理</td>\n</tr>\n<tr>\n<td><strong>棋盘距离</strong></td>\n<td>$G(m,n)&#x3D;max(∣Gh∣,∣Gv∣)$</td>\n<td>$D_8$</td>\n<td>对噪声敏感，边缘较粗</td>\n</tr>\n</tbody></table>\n<p> 二、三种“距离度量”的几何理解</p>\n<table>\n<thead>\n<tr>\n<th>距离类型</th>\n<th>数学定义</th>\n<th>直观含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>欧氏距离 $D_e$</strong></td>\n<td>$\\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$</td>\n<td>直线距离（最精确）</td>\n</tr>\n<tr>\n<td><strong>城市街区距离 $D_4$</strong></td>\n<td>$∥x2−x1∥+∥y2−y1∥$</td>\n<td>只能横向或纵向移动（如棋盘车）</td>\n</tr>\n<tr>\n<td><strong>棋盘距离 $D_8$</strong></td>\n<td>$max(∣x2−x1∣,∣y2−y1∣)$</td>\n<td>可横向、纵向或斜向移动（如棋盘王）</td>\n</tr>\n</tbody></table>\n<p>三、应用建议总结（记忆口诀）</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方法</th>\n<th>记忆口诀</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>医疗分析、高精度检测</td>\n<td>欧氏距离（公式1）</td>\n<td>要精细，用“欧”</td>\n</tr>\n<tr>\n<td>实时嵌入式、快速响应</td>\n<td>城市街区（公式2）</td>\n<td>要快速，选“街”</td>\n</tr>\n<tr>\n<td>初步筛选、容忍粗糙边缘</td>\n<td>棋盘距离（公式3）</td>\n<td>快粗糙，用“棋”</td>\n</tr>\n</tbody></table>\n<h3 id=\"方向梯度法\"><a href=\"#方向梯度法\" class=\"headerlink\" title=\"方向梯度法\"></a>方向梯度法</h3><h4 id=\"Prewitt算子\"><a href=\"#Prewitt算子\" class=\"headerlink\" title=\"Prewitt算子\"></a>Prewitt算子</h4><table>\n<thead>\n<tr>\n<th>方向</th>\n<th>名称</th>\n<th>模板 $W_i$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>东</td>\n<td>$W_0$</td>\n<td>$\\begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>东北</td>\n<td>$W_1$</td>\n<td>$\\begin{bmatrix} 0 &amp; 1 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; -1 &amp; 0 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>北</td>\n<td>$W_2$</td>\n<td>$\\begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ -1 &amp; -1 &amp; -1 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>西北</td>\n<td>$W_3$</td>\n<td>$\\begin{bmatrix} 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; -1 \\ 0 &amp; -1 &amp; -1 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>西</td>\n<td>$W_4$</td>\n<td>$\\begin{bmatrix} 1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>西南</td>\n<td>$W_5$</td>\n<td>$\\begin{bmatrix} 0 &amp; -1 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\ 1 &amp; 1 &amp; 0 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>南</td>\n<td>$W_6$</td>\n<td>$\\begin{bmatrix} -1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 \\end{bmatrix}$</td>\n</tr>\n<tr>\n<td>东南</td>\n<td>$W_7$</td>\n<td>$\\begin{bmatrix} -1 &amp; -1 &amp; 0 \\ -1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\end{bmatrix}$</td>\n</tr>\n</tbody></table>\n<p>使用方式：</p>\n<p>对于每个像素 $(m,n)$，分别将图像的 3×3 邻域与这 8 个模板进行卷积，得到 8 个响应值 $R_i(m,n)$，再选取最大值作为最终边缘响应：<br>$$<br>G(m,n) &#x3D; \\max_i R_i(m,n)<br>$$</p>\n<h4 id=\"Kirsch算子\"><a href=\"#Kirsch算子\" class=\"headerlink\" title=\"Kirsch算子\"></a>Kirsch算子</h4><table>\n<thead>\n<tr>\n<th>方向</th>\n<th>名称</th>\n<th>模板 $W_i$</th>\n<th>检测边缘方向</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>东</td>\n<td>$W_0$</td>\n<td>$\\begin{bmatrix} -3 &amp; -3 &amp; 5 \\ -3 &amp; 0 &amp; 5 \\ -3 &amp; -3 &amp; 5 \\end{bmatrix}$</td>\n<td>垂直边缘（东-西）</td>\n</tr>\n<tr>\n<td>东北</td>\n<td>$W_1$</td>\n<td>$\\begin{bmatrix} -3 &amp; 5 &amp; 5 \\ -3 &amp; 0 &amp; 5 \\ -3 &amp; -3 &amp; -3 \\end{bmatrix}$</td>\n<td>西北-东南对角线</td>\n</tr>\n<tr>\n<td>北</td>\n<td>$W_2$</td>\n<td>$\\begin{bmatrix} 5 &amp; 5 &amp; 5 \\ -3 &amp; 0 &amp; -3 \\ -3 &amp; -3 &amp; -3 \\end{bmatrix}$</td>\n<td>水平边缘（北-南）</td>\n</tr>\n<tr>\n<td>西北</td>\n<td>$W_3$</td>\n<td>$\\begin{bmatrix} 5 &amp; 5 &amp; -3 \\ 5 &amp; 0 &amp; -3 \\ -3 &amp; -3 &amp; -3 \\end{bmatrix}$</td>\n<td>东北-西南对角线</td>\n</tr>\n<tr>\n<td>西</td>\n<td>$W_4$</td>\n<td>$\\begin{bmatrix} 5 &amp; -3 &amp; -3 \\ 5 &amp; 0 &amp; -3 \\ 5 &amp; -3 &amp; -3 \\end{bmatrix}$</td>\n<td>垂直边缘（西-东）</td>\n</tr>\n<tr>\n<td>西南</td>\n<td>$W_5$</td>\n<td>$\\begin{bmatrix} -3 &amp; -3 &amp; -3 \\ 5 &amp; 0 &amp; -3 \\ 5 &amp; 5 &amp; -3 \\end{bmatrix}$</td>\n<td>东南-西北对角线</td>\n</tr>\n<tr>\n<td>南</td>\n<td>$W_6$</td>\n<td>$\\begin{bmatrix} -3 &amp; -3 &amp; -3 \\ -3 &amp; 0 &amp; -3 \\ 5 &amp; 5 &amp; 5 \\end{bmatrix}$</td>\n<td>水平边缘（南-北）</td>\n</tr>\n<tr>\n<td>东南</td>\n<td>$W_7$</td>\n<td>$\\begin{bmatrix} -3 &amp; -3 &amp; -3 \\ -3 &amp; 0 &amp; 5 \\ -3 &amp; 5 &amp; 5 \\end{bmatrix}$</td>\n<td>西南-东北对角线</td>\n</tr>\n</tbody></table>\n<p>计算步骤</p>\n<p>步骤一：对图像每个像素，用 8 个 Kirsch 模板分别进行卷积（即计算邻域与模板的乘积和）：<br>$$<br>R_i(m,n) &#x3D; f(m,n) * W_i \\quad (i &#x3D; 0 \\sim 7)<br>$$<br>步骤二：在这 8 个响应中选择最大值作为最终的边缘强度：<br>$$<br>G(m,n) &#x3D; \\max_i R_i(m,n)<br>$$</p>\n<h3 id=\"二阶导数算子法\"><a href=\"#二阶导数算子法\" class=\"headerlink\" title=\"二阶导数算子法\"></a>二阶导数算子法</h3><h4 id=\"拉普拉斯算子\"><a href=\"#拉普拉斯算子\" class=\"headerlink\" title=\"拉普拉斯算子\"></a>拉普拉斯算子</h4><p>定义为：<br>$$<br>\\nabla^2 f &#x3D; \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2}<br>$$<br>常用模板一（4邻域）：<br>$$<br>L &#x3D; \\begin{bmatrix}<br>0 &amp; 1 &amp; 0 \\<br>1 &amp; -4 &amp; 1 \\<br>0 &amp; 1 &amp; 0<br>\\end{bmatrix}<br>$$<br>常用模板二（8邻域）：<br>$$<br>L &#x3D; \\begin{bmatrix}<br>1 &amp; 1 &amp; 1 \\<br>1 &amp; -8 &amp; 1 \\<br>1 &amp; 1 &amp; 1<br>\\end{bmatrix}<br>$$<br>模板特点说明：</p>\n<table>\n<thead>\n<tr>\n<th>模板类型</th>\n<th>名称</th>\n<th>邻域类型</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>模板一</td>\n<td>4邻域拉普拉斯</td>\n<td>十字形</td>\n<td>计算量小，响应清晰</td>\n</tr>\n<tr>\n<td>模板二</td>\n<td>8邻域拉普拉斯</td>\n<td>十字 + 对角线</td>\n<td>响应更强，适用于更复杂的边缘结构</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>不依赖方向，检测速度快</td>\n<td>对噪声极为敏感</td>\n</tr>\n<tr>\n<td>可检测所有方向的边缘</td>\n<td>边缘位置不如一阶导数精确</td>\n</tr>\n</tbody></table>\n<h4 id=\"LOG算子\"><a href=\"#LOG算子\" class=\"headerlink\" title=\"LOG算子\"></a>LOG算子</h4><p>LoG 算子是将 <strong>高斯滤波器（Gaussian）</strong> 与 <strong>拉普拉斯算子（Laplacian）</strong> 相结合的边缘检测方法，用于先平滑图像，再检测边缘，从而 <strong>降低拉普拉斯算子对噪声的敏感性</strong>。</p>\n<p>其核心思想是：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>先对图像进行高斯模糊（降噪），再使用拉普拉斯算子检测边缘。</strong></p></blockquote>\n<p> <strong>离散模板（示例）</strong></p>\n<p>常用的是对标准二维高斯函数的拉普拉斯求导，生成 <strong>离散卷积模板</strong>。一个常见的 5×5 离散 LoG 模板如下：</p>\n<p>（σ ≈ 1.4）<br>$$<br>\\text{LoG} &#x3D; \\begin{bmatrix}<br>0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\<br>0 &amp; -1 &amp; -2 &amp; -1 &amp; 0 \\<br>-1 &amp; -2 &amp; 16 &amp; -2 &amp; -1 \\<br>0 &amp; -1 &amp; -2 &amp; -1 &amp; 0 \\<br>0 &amp; 0 &amp; -1 &amp; 0 &amp; 0<br>\\end{bmatrix}<br>$$</p>\n<ul>\n<li><strong>中心正值，周围为负值或0</strong></li>\n<li><strong>和为0</strong>（因为平滑之后再检测边缘）</li>\n</ul>\n<h3 id=\"各类算子特点\"><a href=\"#各类算子特点\" class=\"headerlink\" title=\"各类算子特点\"></a>各类算子特点</h3><p>平滑模版：</p>\n<ul>\n<li>模版内系数全正</li>\n<li>模版内系数和为1</li>\n</ul>\n<p>锐化模版</p>\n<ul>\n<li>系数有正有负，表示差分运算</li>\n<li>模版内系数和为1</li>\n</ul>\n<p>边缘检测模版</p>\n<ul>\n<li>系数有正有负，表示差分运算</li>\n<li>模版内系数和为0</li>\n</ul>\n<h2 id=\"阈值分割\"><a href=\"#阈值分割\" class=\"headerlink\" title=\"阈值分割\"></a>阈值分割</h2><h3 id=\"极小值阈值分割\"><a href=\"#极小值阈值分割\" class=\"headerlink\" title=\"极小值阈值分割\"></a>极小值阈值分割</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;</span><br><span class=\"line\">G0 = imread(<span class=\"string\">&#x27;rabbit.jpg&#x27;</span>);      <span class=\"comment\">% 读取彩色图像</span></span><br><span class=\"line\">G = rgb2gray(G0);              <span class=\"comment\">% 转换为灰度图</span></span><br><span class=\"line\">imshow(G);                     <span class=\"comment\">% 显示原图</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imhist(G);             <span class=\"comment\">% 显示灰度直方图</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 计算直方图差分</span></span><br><span class=\"line\">[h, x] = imhist(G);            <span class=\"comment\">% h: 直方图频数, x: 灰度级(0-255)</span></span><br><span class=\"line\">df1 = diff(h);                 <span class=\"comment\">% 一阶差分（直方图斜率）</span></span><br><span class=\"line\">df2 = diff(df1);               <span class=\"comment\">% 二阶差分（曲率变化）</span></span><br><span class=\"line\">[m, n] = <span class=\"built_in\">size</span>(df2);</span><br><span class=\"line\">T = <span class=\"number\">0</span>;                         <span class=\"comment\">% 初始化阈值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 自动阈值选择：寻找直方图的&quot;谷底&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span>:m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(df1(<span class=\"built_in\">i</span>+<span class=\"number\">1</span>)) &lt;= <span class=\"number\">0.001</span> &amp;&amp; df2(<span class=\"built_in\">i</span>) &gt; <span class=\"number\">0</span>)  <span class=\"comment\">% 条件：斜率接近0且曲率凸起</span></span><br><span class=\"line\">        T = x(<span class=\"built_in\">i</span>+<span class=\"number\">2</span>);            <span class=\"comment\">% 确定阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">G_bw = im2bw(G, T/<span class=\"number\">255</span>);        <span class=\"comment\">% 二值化（阈值归一化到[0,1]）</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; </span><br><span class=\"line\">imshow(G_bw);          <span class=\"comment\">% 显示二值结果</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代阈值\"><a href=\"#迭代阈值\" class=\"headerlink\" title=\"迭代阈值\"></a>迭代阈值</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear;</span><br><span class=\"line\">A = imread(<span class=\"string\">&#x27;tree.bmp&#x27;</span>);  imshow(A);  <span class=\"comment\">% 读取并显示原图</span></span><br><span class=\"line\">h = imhist(A);                       <span class=\"comment\">% 计算灰度直方图</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 初始化阈值</span></span><br><span class=\"line\">t = [];  </span><br><span class=\"line\">t(<span class=\"number\">1</span>) = (<span class=\"built_in\">min</span>(A(:)) + <span class=\"built_in\">max</span>(A(:))) / <span class=\"number\">2</span>;  <span class=\"comment\">% 初始阈值=灰度范围中点</span></span><br><span class=\"line\">MAX = <span class=\"number\">500</span>;  L = <span class=\"number\">256</span>;                 <span class=\"comment\">% 最大迭代次数/灰度级数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span>:MAX</span><br><span class=\"line\">    <span class=\"comment\">% 计算低灰度类（背景）的灰度总和(s1)和像素数(s2)</span></span><br><span class=\"line\">    s1 = <span class=\"number\">0</span>; s2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k = <span class=\"number\">1</span>:t(<span class=\"built_in\">i</span>)</span><br><span class=\"line\">        s1 = s1 + h(k) * k;          <span class=\"comment\">% 加权灰度求和</span></span><br><span class=\"line\">        s2 = s2 + h(k);              <span class=\"comment\">% 像素数量求和</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    zb = s1 / s2;                    <span class=\"comment\">% 背景平均灰度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">% 计算高灰度类（前景）的灰度总和(s3)和像素数(s4)</span></span><br><span class=\"line\">    s3 = <span class=\"number\">0</span>; s4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k = t(<span class=\"built_in\">i</span>)+<span class=\"number\">1</span>:L</span><br><span class=\"line\">        s3 = s3 + h(k) * k;</span><br><span class=\"line\">        s4 = s4 + h(k);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    zo = s3 / s4;                    <span class=\"comment\">% 前景平均灰度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">% 更新阈值</span></span><br><span class=\"line\">    t(<span class=\"built_in\">i</span>+<span class=\"number\">1</span>) = <span class=\"built_in\">floor</span>((zb + zo) / <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">% 终止条件：阈值变化小于1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">abs</span>(t(<span class=\"built_in\">i</span>+<span class=\"number\">1</span>) - t(<span class=\"built_in\">i</span>)) &lt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 应用最终阈值tt进行二值化</span></span><br><span class=\"line\">tt = t(<span class=\"built_in\">i</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">B = A;</span><br><span class=\"line\">B(B &lt; tt) = <span class=\"number\">0</span>;      <span class=\"comment\">% 低于阈值设为0（黑）</span></span><br><span class=\"line\">B(B &gt;= tt) = <span class=\"number\">255</span>;   <span class=\"comment\">% 高于阈值设为255（白）</span></span><br><span class=\"line\"><span class=\"built_in\">figure</span>; imshow(B);  <span class=\"comment\">% 显示结果</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"区域生长\"><a href=\"#区域生长\" class=\"headerlink\" title=\"区域生长\"></a>区域生长</h2><p>基本步骤（简单区域生长）</p>\n<ol>\n<li><strong>选定种子点</strong>（如坐标 $(m_0, n_0)$，灰度为 $f_0$）</li>\n<li>设定阈值 $T$（灰度相似性准则）</li>\n<li>将与种子点相邻的像素中，灰度值与 $f_0$ 差值 &lt; $T$ 的像素并入区域</li>\n<li>将新加入的像素当作种子，继续扩展</li>\n<li><strong>直到没有新像素满足准则为止</strong></li>\n</ol>\n<p><img src=\"/../images/2.png\"></p>\n<h1 id=\"九\"><a href=\"#九\" class=\"headerlink\" title=\"九\"></a>九</h1><h2 id=\"链码表达\"><a href=\"#链码表达\" class=\"headerlink\" title=\"链码表达\"></a>链码表达</h2><p><img src=\"/../images/3.png\"></p>\n<p><strong>差分码（后一位减前一位）</strong></p>\n<p><img src=\"/../images/4.png\"></p>\n<p>注：差分码有<strong>旋转不变性</strong></p>\n<p><strong>形状数</strong></p>\n<ul>\n<li><strong>形状数 &#x3D; 差分码的循环排列中最小的一个数</strong></li>\n<li>它是一种<strong>旋转不变表示</strong>：即相同的边界轮廓，即使旋转后，形状数也不变。</li>\n<li>也叫<strong>最小表示</strong>（Minimum Representation）</li>\n</ul>\n<p>实例</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>差分码是：<code>33133030</code><br>要求形状数</p></blockquote>\n<p>步骤：找出差分码的所有循环排列，取字典序最小者</p>\n<p>所有循环排列（从不同位置开始）：</p>\n<ol>\n<li>33133030</li>\n<li>31330303</li>\n<li>13303033</li>\n<li>33030331</li>\n<li>30303313</li>\n<li>03033133 ✅</li>\n<li>30331330</li>\n<li>03313303</li>\n</ol>\n<p>其中字典序（按从左到右大小）最小的是：</p>\n<p>→ <code>03033133</code></p>\n<p>这就是<strong>形状数</strong>。</p>\n<h2 id=\"目标的四叉树、二叉树表达\"><a href=\"#目标的四叉树、二叉树表达\" class=\"headerlink\" title=\"目标的四叉树、二叉树表达\"></a>目标的四叉树、二叉树表达</h2><p>四叉树</p>\n<p><img src=\"/../images/5.png\"></p>\n<p>二叉树</p>\n<p><img src=\"/../images/6.png\"></p>\n<p><strong>n级完全四叉树的结点总数公式</strong></p>\n<p>设：</p>\n<ul>\n<li>根节点为第 0 层；</li>\n<li>四叉树总共有 <strong>n+1 层</strong>（从 0 到 n）；</li>\n<li>每层是完全展开的（即每个非叶节点都有 4 个子节点）；</li>\n</ul>\n<p>那么第 k 层的结点数为：<br>$$<br>4^k<br>$$<br>总结点数 N：<br>$$<br>N &#x3D; \\sum_{k&#x3D;0}^{n} 4^k &#x3D; 4^0 + 4^1 + 4^2 + \\cdots + 4^n<br>$$<br>这是一个<strong>等比数列求和</strong>，公比为 4：<br>$$<br>N &#x3D; \\frac{4^{n+1} - 1}{4 - 1} &#x3D; \\frac{4^{n+1} - 1}{3}<br>$$</p>\n<h2 id=\"目标骨架表达\"><a href=\"#目标骨架表达\" class=\"headerlink\" title=\"目标骨架表达\"></a>目标骨架表达</h2><p>中轴变换方法</p>\n<p><img src=\"/../images/7.png\"></p>\n<p><img src=\"/../images/8.png\"></p>\n","text":"考点复习一二图形和图像的区别（选择）图形：矢量图，以几何数学为基础，由点、线、圆等图元组成，仅记录点的坐标数据及绘图命令 图像：点阵图，用像素来描述的图，记录每...","permalink":"/post/考点复习","photos":[],"count_time":{"symbolsCount":"38k","symbolsTime":"34 mins."},"categories":[],"tags":[{"name":"数字图像处理","slug":"数字图像处理","count":1,"path":"api/tags/数字图像处理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%80%83%E7%82%B9%E5%A4%8D%E4%B9%A0\"><span class=\"toc-text\">考点复习</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%8C\"><span class=\"toc-text\">一二</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%BD%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%89\"><span class=\"toc-text\">图形和图像的区别（选择）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87\"><span class=\"toc-text\">数字图像处理常用的输入输出设备</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%89%B2%E5%BD%A9%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">色彩模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RGB%E9%85%8D%E6%AF%94\"><span class=\"toc-text\">RGB配比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HSI%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">HSI模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%91%E7%99%BD%E4%BA%8C%E5%80%BC%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">黑白二值模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E5%9B%BE%E5%83%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">计算图像的存储空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%83%8F%E6%95%B0%E5%AD%97%E5%8C%96\"><span class=\"toc-text\">图像数字化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89\"><span class=\"toc-text\">三</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%82%B9%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">点运算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">算术运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">加法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E6%B3%95\"><span class=\"toc-text\">减法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">乘法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">除法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%A0%E4%BD%95%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">几何运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B0%B4%E5%B9%B3%E9%95%9C%E5%83%8F%EF%BC%9A\"><span class=\"toc-text\">水平镜像：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix\"><span class=\"toc-text\">$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9E%82%E7%9B%B4%E9%95%9C%E5%83%8F%EF%BC%9A\"><span class=\"toc-text\">垂直镜像：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-1\"><span class=\"toc-text\">$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E7%A7%BB\"><span class=\"toc-text\">平移</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-2\"><span class=\"toc-text\">$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\">旋转</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-3\"><span class=\"toc-text\">$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E9%82%BB%E8%BF%91%E5%B7%AE%E5%80%BC%EF%BC%9A\"><span class=\"toc-text\">最邻近差值：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E7%BA%BF%E6%80%A7%E5%86%85%E6%8F%92%E5%80%BC%EF%BC%9A\"><span class=\"toc-text\">双线性内插值：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E6%AC%A1%E5%8D%B7%E7%A7%AF%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">三次卷积法：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%A9%E6%94%BE\"><span class=\"toc-text\">缩放</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#begin-bmatrix-x-1-y-1-1-end-bmatrix-4\"><span class=\"toc-text\">$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E7%BD%AE\"><span class=\"toc-text\">转置</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B\"><span class=\"toc-text\">四</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">傅里叶变换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%BB%B4%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E6%89%8B%E5%8A%A8%E8%AE%A1%E7%AE%97%EF%BC%8C%E4%BB%8E-f-%E8%AE%A1%E7%AE%97-F\"><span class=\"toc-text\">一维傅立叶变换的手动计算，从 f 计算 F</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">手动计算</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span class=\"toc-text\">二维傅里叶变换（编程实现）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">傅里叶变换两个应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E8%B0%B1%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">双谱重构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E7%89%88%E5%8C%B9%E9%85%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">模版匹配定位</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">离散余弦变换</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94\"><span class=\"toc-text\">五</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E6%8B%89%E4%BC%B8\"><span class=\"toc-text\">图像灰度拉伸</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96\"><span class=\"toc-text\">直方图均衡化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%B7%A5%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">手工计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%BD%92%E5%B9%B6%E5%8C%96%E6%89%8B%E5%B7%A5%E8%AE%A1%E7%AE%97%EF%BC%88SML%E5%8D%95%E6%98%A0%E5%B0%84%E8%A1%A8%EF%BC%89\"><span class=\"toc-text\">直方图的归并化手工计算（SML单映射表）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E5%9F%9F%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">空域滤波</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2%EF%BC%88%E5%B9%B3%E6%BB%91%EF%BC%89\"><span class=\"toc-text\">均值滤波（平滑）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%EF%BC%88%E5%B9%B3%E6%BB%91%EF%BC%89\"><span class=\"toc-text\">中值滤波（平滑）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BB%A4%E6%B3%A2%E4%B8%8E%E5%99%AA%E5%A3%B0\"><span class=\"toc-text\">滤波与噪声</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%EF%BC%88%E9%94%90%E5%8C%96%EF%BC%89%EF%BC%88sobel%E7%AE%97%E5%AD%90%EF%BC%89\"><span class=\"toc-text\">锐化滤波（锐化）（sobel算子）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%91%E5%9F%9F%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">频域滤波</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%90%86%E6%83%B3%E6%BB%A4%E6%B3%A2%E5%99%A8\"><span class=\"toc-text\">理想滤波器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">低通滤波</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">高通滤波</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%B4%E7%89%B9%E6%B2%83%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%99%A8\"><span class=\"toc-text\">巴特沃斯滤波器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2-1\"><span class=\"toc-text\">低通滤波</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2-1\"><span class=\"toc-text\">高通滤波</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">彩色图像增强</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%AA%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">伪彩色图像增强</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%83%AD%E9%87%91%E5%B1%9E%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">热金属编码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%A9%E8%99%B9%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">彩虹编码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%87%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">假彩色图像增强</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9C%9F%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">真彩色图像增强</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD\"><span class=\"toc-text\">六</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%86%97%E4%BD%99\"><span class=\"toc-text\">图像压缩和冗余</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">行程编码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">哈夫曼编码</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83\"><span class=\"toc-text\">七</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%86%A8%E8%83%80\"><span class=\"toc-text\">膨胀</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%85%90%E8%9A%80\"><span class=\"toc-text\">腐蚀</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">开运算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">闭运算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">对比</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB\"><span class=\"toc-text\">八</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">边缘检测</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E4%BA%A4%E6%A2%AF%E5%BA%A6%E7%AE%97%E5%AD%90%E6%B3%95\"><span class=\"toc-text\">正交梯度算子法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%99%E5%AE%9A%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%87%BD%E6%95%B0-f-x-y-%EF%BC%8C%E5%85%B6%E6%A2%AF%E5%BA%A6%E4%B8%BA%EF%BC%9A-nabla-f-x-y-begin-bmatrix-G-x-G-y-end-bmatrix\"><span class=\"toc-text\">给定图像灰度函数 $f(x, y)$，其梯度为：$$\\nabla f(x, y) &#x3D;\\begin{bmatrix}G_x \\G_y\\end{bmatrix}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E9%98%B6%E5%B7%AE%E5%88%86%E8%BF%91%E4%BC%BC%E6%A2%AF%E5%BA%A6%E6%B3%95\"><span class=\"toc-text\">一阶差分近似梯度法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%97%E5%AD%90%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">算子总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E4%BA%A4%E6%A2%AF%E5%BA%A6%E7%AE%97%E5%AD%90%EF%BC%88%E5%B7%AE%E5%88%86%E7%89%88-1001%EF%BC%89\"><span class=\"toc-text\">正交梯度算子（差分版 1001）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Roberts-%E7%AE%97%E5%AD%90%EF%BC%88%E7%BB%8F%E5%85%B8%E5%AF%B9%E8%A7%92%E7%BA%BF%E8%BE%B9%E7%BC%98%EF%BC%89\"><span class=\"toc-text\">Roberts 算子（经典对角线边缘）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Sobel-%E7%AE%97%E5%AD%90%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%8C%E5%B8%A6%E5%8A%A0%E6%9D%83%EF%BC%89\"><span class=\"toc-text\">Sobel 算子（常用，带加权）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Prewitt-%E7%AE%97%E5%AD%90%EF%BC%88%E4%B8%8E-Sobel-%E7%B1%BB%E4%BC%BC%EF%BC%8C%E4%BD%86%E4%B8%8D%E5%8A%A0%E6%9D%83%EF%BC%89\"><span class=\"toc-text\">Prewitt 算子（与 Sobel 类似，但不加权）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A2%AF%E5%BA%A6%E5%9B%BE%E5%83%8F\"><span class=\"toc-text\">梯度图像</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E5%90%91%E6%A2%AF%E5%BA%A6%E6%B3%95\"><span class=\"toc-text\">方向梯度法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Prewitt%E7%AE%97%E5%AD%90\"><span class=\"toc-text\">Prewitt算子</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Kirsch%E7%AE%97%E5%AD%90\"><span class=\"toc-text\">Kirsch算子</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0%E7%AE%97%E5%AD%90%E6%B3%95\"><span class=\"toc-text\">二阶导数算子法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90\"><span class=\"toc-text\">拉普拉斯算子</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#LOG%E7%AE%97%E5%AD%90\"><span class=\"toc-text\">LOG算子</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">各类算子特点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2\"><span class=\"toc-text\">阈值分割</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%81%E5%B0%8F%E5%80%BC%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2\"><span class=\"toc-text\">极小值阈值分割</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E9%98%88%E5%80%BC\"><span class=\"toc-text\">迭代阈值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF\"><span class=\"toc-text\">区域生长</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B9%9D\"><span class=\"toc-text\">九</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E7%A0%81%E8%A1%A8%E8%BE%BE\"><span class=\"toc-text\">链码表达</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%E7%9A%84%E5%9B%9B%E5%8F%89%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E8%BE%BE\"><span class=\"toc-text\">目标的四叉树、二叉树表达</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%E9%AA%A8%E6%9E%B6%E8%A1%A8%E8%BE%BE\"><span class=\"toc-text\">目标骨架表达</span></a></li></ol></li></ol>","author":{"name":"yona-lia","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/143192323?v=4","link":"/","description":"May this journey end in the stars","socials":{"github":"https://github.com/yona-lia","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2025-06-10T13:34:40.545Z","updated":"2025-06-10T13:34:40.545Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":444,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"yona-lia","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/143192323?v=4","link":"/","description":"May this journey end in the stars","socials":{"github":"https://github.com/yona-lia","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}