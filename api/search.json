[{"id":"cf3e005cfd96f68780fbdebaaab6e37f","title":"考点复习","content":"考点复习一二图形和图像的区别（选择）图形：矢量图，以几何数学为基础，由点、线、圆等图元组成，仅记录点的坐标数据及绘图命令\n图像：点阵图，用像素来描述的图，记录每个像素的位置和灰度\n数字图像处理常用的输入输出设备触摸屏既是输入设备也是输出设备\n输入设备：键盘，鼠标，图形输入板，数码相机，扫描仪，光密度仪等\n输出设备：显示器，打印机，图像拷贝机和绘图仪等\n色彩模型RGB配比整数：红（255,0,0）绿（0,255,0）蓝（0,0,255）白（255,255,255）黑（0,0,0）品红（红+蓝）（255,0,255）青（绿+蓝）（0,255,255）黄（红+绿）（255,255,0）\n归一化：红（1,0,0）绿（0,1,0）蓝（0,0,1）白（1,1,1）黑（0,0,0）品红（红+蓝）（1,0,1）青（绿+蓝）（0,1,1）黄（红+绿）（1,1,0）\nHSI模型H：色度（色度由角度表示，表示最接近什么基本色）\n0°是红色，120°是绿色，240°是蓝色\nS：饱和度（色环的圆心到某彩色点的半径长度，外围圆周饱和度为1，圆心饱和度为0）\nI：亮度（光照强度，确定像素的整体亮度）\n黑白二值模型二值模型：只有黑白两种颜色，其中黑是0，白是1。\n灰度模型：显示从白到黑的256个灰度级，黑色是0，白色是255.\n索引彩色：显示256种颜色\n真彩色：显示$2^{26}$种颜色\n计算图像的存储空间空间分辨率：$n*m$\n幅度分辨率：$2^k$\n占用空间：$m *n *k$（单位bit）\n图像数字化采样：空间离散化\n量化：灰度离散化\n三点运算$G&#x3D;aF+b$（F为输入的灰度值，G为输出的灰度值，a为斜率，b为截距）\n对比度：\n$a&gt;1,b&#x3D;0$：对比度增大\n$0&lt;a&lt;1,b&#x3D;0$：对比度减小\n灰度值：\n$a&#x3D;1,b&gt;0$：灰度值上移，亮度增加\n$a&#x3D;1,b&lt;0$：灰度值下移，亮度降低\n反相：\n$a&#x3D;-1,b&#x3D;255$\n算术运算加法$C(x,y)&#x3D;A(x,y)+B(x,y)$\n主要应用：\n去除“叠加性”噪音，生成图像叠加效果\n图像叠加方法：\n取均值：$g(x,y)&#x3D;f(x,y)&#x2F;2+h(x,y)&#x2F;2$\n推广：$g(x,y)&#x3D;af(x,y)+bh(x,y)（a+b&#x3D;1）$\n加法运算函数：$Z &#x3D; 0.5 * X + 0.5 * Y$（不可以合并写，会出问题）\nZ = imadd(X,Y);\n减法$g(x,y) &#x3D; T_2(x,y) - T_1(x,y)$\n差值图像显示问题：$g(x,y)[-255,255]——-&gt;g(x,y)[0,255]$\n解决方法：\n方法一（线性平移和缩放）$$g(x,y)&#x3D;\\frac{g(x,y+255)}{2}$$方法二（归一化到动态范围）$$g(x,y)&#x3D;(g(x,y)-g_{min}(x,y)\\times \\frac{255}{g_{max}(x,y)-g_{min}(x,y)})$$减法运算函数：$Z&#x3D;X-Y$（要求X和Y大小一致，数组元素类型一致）\nZ=imsubtract(X,Y);\n乘法$C (x, y)＝A (x, y)*B (x, y)$\n主要应用：\n用二值图像与原图像做乘法（矩阵点乘），得到需要的子图像\n乘法运算函数：$Z&#x3D;X*Y$（X和Y做点乘，大小一致，数组元素类型一致）\nZ=immulyiply(X,Y);\n除法$C (x, y) ＝A (x, y) &#x2F;B (x, y)$\n主要应用：\n用来改变图像的灰度级，校正成像设备的非线性影响\n除法运算函数：$Z&#x3D;X&#x2F;Y$（X和Y做点除，大小一致，数组元素类型一致）\nZ=imdivide(X,Y);\n几何运算镜像镜像种类：水平镜像，垂直镜像\n水平镜像：$$x_1 &#x3D; -x_0, \\quad y_1 &#x3D; y_0$$\n$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\\begin{bmatrix}-1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{bmatrix}x_0 \\y_0 \\1\\end{bmatrix}$$\n水平镜像时，由于矩阵下标不能为负，实际上要对图像矩阵左右翻转\n水平镜像函数：B = fliplr(A)（将矩阵A左右翻转，实现水平镜像）\n垂直镜像：$$x_1 &#x3D; x_0, \\quad y_1 &#x3D; -y_0$$\n$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{bmatrix}x_0 \\y_0 \\1\\end{bmatrix}$$\n垂直镜像时，由于矩阵下标不能为负，实际上要对图像矩阵上下翻转\n垂直镜像函数：B = flipud(A)（将矩阵A上下翻转，实现垂直镜像）\n平移$$x_1 &#x3D; x_0 + t_x,\\quad y_1 &#x3D; y_0 + t_y$$\n$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{bmatrix}x_0 \\y_0 \\1\\end{bmatrix}$$\n其中\n$A——tx&#x3D;2,ty&#x3D;1——-&gt;B$\n$B(2:3,3:3) &#x3D; A(1:2,1:1)$\n推广：$B(1+ty:M, 1+tx:N) &#x3D; A(1:M-ty,1:N-tx)$\n平移函数：B = imtranslate(A,[tx,ty]); （平移A，水平移动tx，垂直移动ty，可正可负）\n代码实现\n123456789101112131415clear all;A= imread(&#x27;bot.bmp&#x27;);imshow(A);[M N]= size(A); B =zeros(M,N,class(A));tx=100;ty=50;for i=1:M\tfor j=1:N\t\tif (i-ty&gt;0) &amp;&amp;(i-ty&lt;M) &amp;&amp;(j-tr&gt;0) &amp;&amp;(j-tr&lt;N)\t\t\tB(i,j)=A(i-ty,j-tx);\t\telse\t\t\tB(i,j)=0;\t\tend\tendendfigure, imshow(B)\n\n旋转$$x_1 &#x3D; x_0 \\cos\\theta - y_0 \\sin\\theta \\y_1 &#x3D; x_0 \\sin\\theta + y_0 \\cos\\theta$$\n$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\\begin{bmatrix}\\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\sin\\theta &amp; \\cos\\theta &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{bmatrix}x_0 \\y_0 \\1\\end{bmatrix}$$\n注意：旋转后会出现很多空洞点，需要差值处理\n差值处理方法：最邻近差值（近邻取样法）、双线性内插值、三次卷积法\n最邻近差值：对带小数的浮点坐标取整，得到整数型坐标。此坐标对应的像素值为目标像素的像素值。\n设目标图像像素映射到源图像坐标为 (x, y)，则：$$I’(i, j) &#x3D; I\\left(\\text{round}(x),\\ \\text{round}(y)\\right)$$\n双线性内插值：从源图像中取出目标点周围的 4 个像素，按水平和垂直方向分别线性插值，进行二维线性插值。\n设源图像中整数像素点：\n\n$(x_0, y_0)$、$(x_1, y_0)$\n$(x_0, y_1)$、$(x_1, y_1)$，其中 $x_0 &#x3D; \\lfloor x \\rfloor$，$x_1 &#x3D; x_0 + 1$\n\n插值过程如下：$$I’(x, y) &#x3D; (1 - a)(1 - b) I(x_0, y_0) + a(1 - b) I(x_1, y_0) + (1 - a)b I(x_0, y_1) + ab I(x_1, y_1)$$其中：\n\n$a &#x3D; x - x_0$，\n$b &#x3D; y - y_0$\n\n三次卷积法：对目标点周围 $4 \\times 4 &#x3D; 16$ 个像素进行插值，采用三次卷积函数加权，精度更高。$$h(x) &#x3D;\\begin{cases}( a + 2)|x|^3 - (a + 3)|x|^2 + 1, &amp; 0 \\le |x| &lt; 1 \\a|x|^3 - 5a|x|^2 + 8a|x| - 4a, &amp; 1 \\le |x| &lt; 2 \\0, &amp; |x| \\ge 2\\end{cases}$$其中，常用 $a &#x3D; -0.5$\n插值值由 16 点卷积结果计算：$$I’(x, y) &#x3D; \\sum_{i&#x3D;-1}^{2} \\sum_{j&#x3D;-1}^{2} I(x_i, y_j) \\cdot h(x - x_i) \\cdot h(y - y_j)$$旋转函数：\nB = imrotate(A,angle)（A逆时针旋转angle角度，返回图像不做修剪，图像要增大）\nB = imrotate(A,angle,&#39;crop&#39;)（A逆时针旋转angle角度，返回图像做修剪，图像大小不变）\n缩放$$x_1 &#x3D; s_x \\cdot x_0,\\quad y_1 &#x3D; s_y \\cdot y_0$$\n$$\\begin{bmatrix}x_1 \\y_1 \\1\\end{bmatrix}\\begin{bmatrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{bmatrix}x_0 \\y_0 \\1\\end{bmatrix}$$\n其中$S_x,S_y&gt;1$图像放大，$S_x,S_y&lt;1$图像缩小\n按任意比例缩小：$S_x&#x3D;S_y&#x3D;S(S&lt;1)$，则需要计算选择的行列\n$MN$大小的原图像缩小后为：$SMSN$\n原图像$A(x,y)$,新图像$B(x,y)$,则：$B(x,y)&#x3D;A(int(xS),int(yS))$\n按不同比例缩小会导致几何畸变\n按任意比例放大：$S_x&#x3D;S_y&#x3D;S(S&gt;1)$\n将原图像放大S倍，则要将一个像素值添在新图像的$S*S$的子块中。\n图像的放大：创立新的像素位置；给新的像素赋灰度值\n最近邻域内插法（产生马赛克）：\n在原图像上寻找最靠近的像素并把它的灰度值赋给栅格上的新像素。$f(x’,y’) &#x3D; f(x,y)$\n缩放公式：B=imresize(A.m)（将A缩放m倍）\n转置转置公式：$B&#x3D;A’$\n四傅里叶变换图像变换是将图像从空域变换到频域，在频域中对图像进行加工，再回到空域的过程。\n空域——-&gt;频域：正变换（傅里叶变换）\n频域——-&gt;空域：逆变换（傅里叶逆变换）\n一维傅立叶变换的手动计算，从 f 计算 F用于离散采样信号的频谱分析，实际中常用于计算机中的实现。\n正变换（DFT）：$$X(k) &#x3D; \\frac{1}{N} \\sum_{k&#x3D;0}^{N-1} X(k) \\cdot e^{j \\frac{2\\pi}{N}kn}, \\quad k &#x3D; 0, 1, …, N-1$$\n逆变换（IDFT）：$$x(n)&#x3D; \\sum_{n&#x3D;0}^{N-1} x(n) \\cdot e^{-j \\frac{2\\pi}{N}kn}, \\quad n &#x3D; 0, 1, …, N-1$$其中：\n\n$x(n)$：长度为 $N$ 的离散时域序列\n$X(k)$：其对应的频域序列\n$N$：序列总长度\n\n手动计算j 是虚数单位$$e^{-j\\theta}&#x3D;cos\\theta-j*sin\\theta$$\n$$f[n] ;&#x3D;; {,1,,2,,3,,4,}, \\qquad N &#x3D; 4.$$\n$$F[k] ;&#x3D;; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n];e^{-,j,\\frac{2\\pi}{4}kn},\\qquad k &#x3D; 0,1,2,3.$$\n$$\\begin{aligned}F[0]&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 0 \\cdot n}&#x3D; \\frac{1}{4}\\bigl[f[0] + f[1] + f[2] + f[3]\\bigr] \\&amp;&#x3D; \\frac{1}{4}(1 + 2 + 3 + 4)&#x3D; \\frac{10}{4}&#x3D; 2.5.\\end{aligned}$$\n$$\\begin{aligned}F[1]&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 1 \\cdot n}&#x3D; \\frac{1}{4}\\Bigl[1\\cdot e^{-j\\cdot 0}\n\n2\\cdot e^{-j,\\frac{\\pi}{2}}\n3\\cdot e^{-j,\\pi}\n4\\cdot e^{-j,\\frac{3\\pi}{2}}\\Bigr] \\[0.5em]&amp;&#x3D; \\frac{1}{4}\\Bigl[1\\cdot (1)\n2\\cdot (-,j)\n3\\cdot (-1)\n4\\cdot (,j)\\Bigr]&#x3D; \\frac{1}{4}\\Bigl[1 - 2j - 3 + 4j\\Bigr] \\[0.5em]&amp;&#x3D; \\frac{1}{4}\\Bigl[(1 - 3) + j,(4 - 2)\\Bigr]&#x3D; \\frac{1}{4}\\bigl[-2 + 2j\\bigr]&#x3D; -,0.5 ;+; 0.5,j.\\end{aligned}$$\n\n$$\\begin{aligned}F[2]&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 2 \\cdot n}&#x3D; \\frac{1}{4}\\Bigl[1\\cdot e^{-j\\cdot 0}\n\n2\\cdot e^{-j,\\pi}\n3\\cdot e^{-j,2\\pi}\n4\\cdot e^{-j,3\\pi}\\Bigr] \\[0.5em]&amp;&#x3D; \\frac{1}{4}\\Bigl[1\\cdot (1)\n2\\cdot (-1)\n3\\cdot (1)\n4\\cdot (-1)\\Bigr]&#x3D; \\frac{1}{4}\\bigl[1 - 2 + 3 - 4\\bigr]&#x3D; \\frac{-2}{4}&#x3D; -,0.5.\\end{aligned}$$\n\n$$\\begin{aligned}F[3]&amp;&#x3D; \\frac{1}{4}\\sum_{n&#x3D;0}^{3} f[n],e^{-,j,\\frac{2\\pi}{4}\\cdot 3 \\cdot n}&#x3D; \\frac{1}{4}\\Bigl[1\\cdot e^{-j\\cdot 0}\n\n2\\cdot e^{-j,\\frac{3\\pi}{2}}\n3\\cdot e^{-j,3\\pi}\n4\\cdot e^{-j,\\frac{9\\pi}{2}}\\Bigr] \\[0.5em]&amp;&#x3D; \\frac{1}{4}\\Bigl[1\\cdot (1)\n2\\cdot (,j)\n3\\cdot (-1)\n4\\cdot (-,j)\\Bigr]&#x3D; \\frac{1}{4}\\bigl[,1 + 2j - 3 - 4j\\bigr] \\[0.5em]&amp;&#x3D; \\frac{1}{4}\\bigl[(1 - 3) + j,(2 - 4)\\bigr]&#x3D; \\frac{1}{4}\\bigl[-2 - 2j\\bigr]&#x3D; -,0.5 ;-; 0.5,j.\\end{aligned}$$\n\n$$\\bigl{,F[0],,F[1],,F[2],,F[3],\\bigr}&#x3D; {,2.5,; -0.5 + 0.5,j,; -0.5,; -0.5 - 0.5,j,}.$$\n二维傅里叶变换（编程实现）简单黑色背景白色方块版\n123456789101112131415161718192021222324252627% 二值图像的二维傅里叶变换及频谱显示clear; clc;%% 1. 创建一个 300×300 的二值图像，中心为白色方块A = zeros(300, 300);                  % 黑色背景图像A(100:200, 100:200) = 1;             % 中心插入一个 101×101 的白色正方形figure;imshow(A); title(&#x27;原始图像&#x27;);pause;  % 等待查看原图，按任意键继续%% 2. 计算图像的二维傅里叶变换F = fft2(A);                         % 计算二维快速傅里叶变换F_mag = abs(F);                      % 取复数频谱的幅度（模）%% 3. 将频谱中心化，并进行对数变换提升可视化效果F_shifted = fftshift(F_mag);         % 将低频移到中心F_log = log(1 + F_shifted);          % 对数变换，压缩动态范围% 归一化到 [0, 1] 区间，便于使用 imshow 显示F_display = mat2gray(F_log);         %% 4. 显示频谱图像figure;imshow(F_display, []);title(&#x27;频谱图（对数变换后）&#x27;);\n\n图片版\n123456789101112131415161718192021clear;                        % 清除工作区变量% 1. 读取图像并显示A = imread(&#x27;lena.bmp&#x27;);       % 读取 lena 图像imshow(A);pause;                        % 暂停，按任意键继续% 2. 将图像转换为 double 类型A1 = im2double(A);            % 避免整数溢出问题% 3. 计算二维傅里叶变换B = fft2(A1);                 % 快速傅里叶变换（复数结果）C = abs(B);                   % 取幅度谱% 4. 中心化频谱图D = fftshift(C);              % 将低频移到中心% 5. 显示频谱图figure;D1 = uint8(D);imshow(D1);\n\n傅里叶变换性质：\n平移性：在空域中图像平移，频域中频谱不变\n旋转性：在空域中旋转a角度，在频域中也旋转a角度\n傅里叶变换两个应用双谱重构**图像的频谱：**代表图像各像素点的亮度信息，即像素显示什么颜色\n**图像的相位谱：**记录图像各像素点位置信息\n利用两个图像的频谱和相位谱，交换相位谱，进行双谱重构。重构出来的图像的轮廓信息与相位谱对应。\n模版匹配定位模版匹配：一种最基本的模式识别方法。研究特定模版图像位于目标图像什么位置，进而识别该图像。\n模版匹配定位是卷机运算的一个应用\n注意：空域的卷积运算等同于频域的点乘运算\n1234567891011121314151617181920clear all;A = imread(&#x27;text.png&#x27;);      % 必须是黑白二值图imshow(A);% 取子图像为模板图像B = A(29:46, 86:101);figure, imshow(B);B(256,256) = 0;              % 扩展模板图像为大图大小% 将模板图像与目标图像进行卷积运算C = fft2(A) .* fft2(rot90(B,2));CI = real(ifft2(C));figure, imshow(CI, []);% 取阈值thresh = 58;figure, imshow(CI &gt; thresh);\n\n离散余弦变换DCT 是一种将信号从“空间域”转化为“频率域”的变换方法，能把图像中的大部分能量集中在少量低频分量中。\n\n\n\n特点\n说明\n\n\n\n实数变换\nDCT 不涉及复数，计算更简单快速\n\n\n能量集中性强\n图像或信号的主要信息集中于变换后的前几个系数\n\n\n常用于压缩编码\n如 JPEG 图像压缩、MP3 音频压缩中都用到 DCT\n\n\n可逆性\n可通过**逆离散余弦变换（IDCT）**恢复原始信号\n\n\n五图像灰度拉伸将原始图像灰度区分为多段，分别做线性变换，即分段线性变换$$G(F) &#x3D;\\begin{cases}\\frac{a’}{a} \\cdot F, &amp; 0 \\leq F &lt; a \\\\frac{b’ - a’}{b - a} \\cdot (F - a) + a’, &amp; a \\leq F &lt; b \\\\frac{M’ - b’}{M - b} \\cdot (F - b) + b’, &amp; b \\leq F \\leq M\\end{cases}$$可以拉伸$[a,b]$区间，让它斜率大于1，来改善区间内图像效果。即$|b’-a’|&gt;|b-a|$\n注意：小于a区间和大于b区间的图像，会造成信息丢失（斜率&lt;1）\n灰度拉伸函数：Y=imadjust(X,[a,b],[a&#39;,b&#39;]);（将X转换为Y，在$[a,b]$内的灰度值对应转为$[a’,b’]$，灰度值要归一）\n代码实现\n12345678910clear; A = imread(&#x27;ballet.bmp&#x27;);       % 读取图像subplot(1,2,1); imshow(A);      % 显示原图像pause;% 图像增强：线性灰度拉伸，输入范围 [0.1, 0.25] 映射到 [0, 0.8]B = imadjust(A, [0.1, 0.25], [0, 0.8]); subplot(1,2,2); imshow(B);      % 显示增强后的图像\n\n直方图均衡化手工计算直方图均衡化步骤：\n1. 给出所有灰度级 $r_k$（$k &#x3D; 0, \\ldots, L - 1$）的所有概率值 $P_r$：\n\n设 $n_j$ 为灰度级 $r_j$ 的像素个数，总像素为 $n$\n\n则概率：$$p_r(r_j) &#x3D; \\frac{n_j}{n}$$\n\n\n2. 求出累积分布函数 $s_k$：$$s_k &#x3D; T(r_k) &#x3D; \\sum_{j&#x3D;0}^{k} p_r(r_j) \\approx \\sum_{j&#x3D;0}^{k} \\frac{n_j}{n} \\quad \\text{，其中 } k &#x3D; 0,1,2,\\dots,L-1$$3. 对 $s_k$ 四舍五入取整：$$s_k &#x3D; \\text{int}\\left[ (L-1) \\cdot s_k + 0.5 \\right]$$\n\n表格里计算的时候不用加0.5\n将归一化的灰度值映射回 $[0, L-1]$ 范围内的整数\n\n4. 确定映射关系：$$r_k \\rightarrow s_k$$\n\n即原灰度 $r_k$ 映射到新的灰度 $s_k$\n\n5. 计算新的概率值 $P’_r$：\n\n用新灰度值统计直方图，生成新的概率分布 $P’_r$\n\n\n\n\n灰度级 $r_k$\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n原始直方图 $P_r$\n0.19\n0.25\n0.21\n0.16\n0.08\n0.06\n0.03\n0.02\n\n\n累积直方图 $S_k$\n0.19\n0.44\n0.65\n0.81\n0.89\n0.95\n0.98\n1.00\n\n\n$S_k$ 变换：$(L-1) \\cdot S_k$\n1.33\n3.33\n4.55\n5.67\n6.23\n6.65\n6.86\n7.00\n\n\n四舍五入取整 $s_k$\n1\n3\n5\n6\n6\n7\n7\n7\n\n\n映射关系 $r_k \\rightarrow s_k$\n0→1\n1→3\n2→5\n3→6\n4→6\n5→7\n6→7\n7→7\n\n\n新直方图 $P’_r$\n0\n0.19\n0\n0.25\n0\n0.21\n0.24\n0.11\n\n\n直方图均衡化函数：Y=histeq(X)（将X的直方图均衡化为Y）\nimhist(X)（显示X的直方图）\n代码实现1234567891011121314clear;% 读取图像A = imread(&#x27;pout.tif&#x27;);% 显示原图像subplot(2,2,1), imshow(A);% 进行直方图均衡化B = histeq(A);% 显示均衡化后的图像subplot(2,2,2), imshow(B);% 显示原图的直方图subplot(2,2,3), imhist(A);% 显示均衡化图的直方图subplot(2,2,4), imhist(B);\n\n直方图的归并化手工计算（SML单映射表）每个灰度级分别和规定直方图相减并取绝对值，取绝对值最小的那个规定灰度级，然后映射\n\n\n\n灰度级 $r_k$\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n原始直方图 $P_r$\n0.19\n0.25\n0.21\n0.16\n0.08\n0.06\n0.03\n0.02\n\n\n原始累计直方图 $S_k$\n0.19\n0.44\n0.65\n0.81\n0.89\n0.95\n0.98\n1.00\n\n\n规定直方图 $P’_z$\n\n\n\n0.20\n\n0.60\n\n0.20\n\n\n规定累计直方图\n\n\n\n0.20\n\n0.80\n\n1.00\n\n\nSML 映射\n3\n3\n5\n5\n5\n7\n7\n7\n\n\n映射对应关系\n0→3\n1→3\n2→5\n3→5\n4→5\n5→7\n6→7\n7→7\n\n\n转换后的直方图\n0\n0\n0\n0.44\n0\n0.45\n0\n0.11\n\n\n空域滤波定义：在图像空间借助模版进行邻域操作的过程\n空域滤波器：上述过程中的模版\n模版定义：一个系数矩阵，通常为奇数（$33$，$55$，$7*7$）\n运算过程：模板在图像上滑动，每个位置计算对应区域的加权和（即卷积操作）。\n模板系数矩阵$$\\begin{bmatrix}k1 &amp; k2 &amp; k3 \\k4 &amp; k5 &amp; k6 \\k7 &amp; k8 &amp; k9 \\\\end{bmatrix}$$图像局部灰度矩阵$$\\begin{bmatrix}s1 &amp; s2 &amp; s3 \\s4 &amp; s5 &amp; s6 \\s7 &amp; s8 &amp; s9 \\\\end{bmatrix}$$求和符号形式（紧凑表示）：$$R &#x3D; \\sum_{i&#x3D;1}^{9} k_i \\cdot s_i$$展开形式：$$R &#x3D; k_1 s_1 + k_2 s_2 + k_3 s_3 + k_4 s_4 + k_5 s_5 + k_6 s_6 + k_7 s_7 + k_8 s_8 + k_9 s_9$$分类：平滑（消除噪声）、锐化（加强图像中的边缘和轮廓）\n平滑：均值滤波，中值滤波\n均值滤波（平滑）均值滤波：将一个像元及其邻域中所有像元的灰度平均赋给输出图像的相应像元，达到平滑目的\n均值滤波模版：模版系数都为1，大小为$33$，$55$，$7*7$\n实例\n输入子图像灰度矩阵（3×3）$$\\begin{bmatrix}2 &amp; 2 &amp; 3 \\7 &amp; 6 &amp; 8 \\7 &amp; 6 &amp; 8 \\\\end{bmatrix}$$模板（均值滤波）\n使用 3×3 均值滤波器，模板系数为均匀权重，归一化后为：$$\\frac{1}{9}\\begin{bmatrix}1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 1 \\\\end{bmatrix}$$计算过程（模板与图像对应元素相乘并求和）\n计算方式为：$$R &#x3D; \\frac{1}{9} \\times (2 + 2 + 3 + 7 + 6 + 8 + 7 + 6 + 8)$$取整后输出灰度值：$$R \\approx 5$$输出图像灰度矩阵（仅中心像素更新）$$\\begin{bmatrix}\n\n&amp; - &amp; - \\\n&amp; 5 &amp; - \\\n&amp; - &amp; - \\\\end{bmatrix}$$注：模版尺寸越大，对噪声消除效果越强，但图像越模糊\n\n均值滤波函数：$h&#x3D;ones(m,m)&#x2F;m^2$（产生一个大小为$m*m$的模版）\nB=imfilter(A,h)（将A用模版h作均值滤波）\n代码实现\n12345678910111213clear;                % 清空工作区变量A = imread(&#x27;face_1.bmp&#x27;); % 读取图像文件imshow(A);            % 显示原始图像% 3×3 均值滤波h1 = ones(3,3)/9;     % 创建3×3归一化均值模板（每个系数=1/9）B1 = imfilter(A, h1); % 对图像A应用模板h1figure; imshow(B1);    % 显示滤波结果B1% 7×7 均值滤波h2 = ones(7,7)/49;    % 创建7×7归一化均值模板（每个系数=1/49）B2 = imfilter(A, h2); % 对图像A应用模板h2figure; imshow(B2);    % 显示滤波结果B2\n\n中值滤波（平滑）中值滤波：用一个模版窗口在图像上滑动，把窗口中像素灰度按值升次排序，将中间值赋给窗口中心的像素。\n优点：抑制噪声，较好的保护边缘轮廓信息\n实例\n子图像灰度矩阵（3×3）$$\\begin{bmatrix}8 &amp; 2 &amp; 4 \\3 &amp; 2 &amp; 5 \\4 &amp; 6 &amp; 4 \\\\end{bmatrix}$$模板（3×3）$$\\begin{bmatrix}1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 1 \\\\end{bmatrix}$$提取局部像素值\n将子图像矩阵按行展开为一维数组：$$[8, 2, 4, 3, 2, 5, 4, 6, 4]$$ 排序\n升序排列后为：$$[2, 2, 3, 4, 4, 4, 5, 6, 8]$$输出灰度值\n取排序中间值（第 5 个元素）为：$$R &#x3D; 4$$输出图像灰度矩阵（仅更新中心像素）$$\\begin{bmatrix}\n\n&amp; - &amp; - \\\n&amp; 4 &amp; - \\\n&amp; - &amp; - \\\\end{bmatrix}$$注：中值滤波后图像轮廓比较清晰\n\n中值滤波函数：B=medfilt2(A,[m m])（将A用模版$m*m$做中值滤波）\n代码实现\n1234567891011clear;                % 清空工作区变量A = imread(&#x27;face_1.bmp&#x27;); % 读取图像文件imshow(A);            % 显示原始图像% 3×3 中值滤波B1 = medfilt2(A, [3 3]); % 对图像A应用3×3中值滤波figure; imshow(B1);    % 显示滤波结果B1% 5×5 中值滤波B2 = medfilt2(A, [5 5]); % 对图像A应用5×5中值滤波figure; imshow(B2);    % 显示滤波结果B2\n\n滤波与噪声噪声：电磁波干扰，光电基本性质，机械运动，元件本身缺陷，电路噪声\n三种噪声：椒盐，高斯，斑点\n**椒盐噪声：**由于图像传感器等产生的黑白相间的噪声，用中值滤波去除\n**高斯噪声：**其密度符合高斯分布，一种随机噪声。用均值滤波去除\n斑点噪声：一种均值为1的乘性噪声，模型为$I(x,y)&#x3D;R(x,y)*F(x,y)$\n其中：$(x,y)$代表图像单元空间方向及距离向坐标\n$I(x,y)$代表所接受的受噪声干扰的SAR图像信息\nR代表未受噪声干扰的SAR图像信息\nF代表与R相对独立的斑点噪声随机变量\n添加噪声：\nB=imnoise(A,&#39;salt &amp; pepper&#39;,d)（给A增加椒盐噪声）\nd为椒盐噪声的密度，缺省值为0.05\nB=imnoise(A,&#39;gaussian&#39;,m,v)（给A增加高斯白噪声）\nm为噪声的白色程度，缺省值为0\nv为噪声的密度，缺省值为0.01\n锐化滤波（锐化）（sobel算子）加强图像中景物的边缘和轮廓。锐化的作用是要使灰度反查增强。\n水平方向（检测垂直边缘）\n 数学表达：$$\\frac{\\partial f(x, y)}{\\partial x}$$Sobel模板（X方向）：$$G_x &#x3D;\\begin{bmatrix}1 &amp; 0 &amp; -1 \\2 &amp; 0 &amp; -2 \\1 &amp; 0 &amp; -1 \\\\end{bmatrix}$$作用：\n\n检测图像中 垂直边缘（例如：建筑物轮廓、柱子）\n强调图像中水平方向的灰度变化\n\n垂直方向（检测水平方向边缘）\n数学表达：$$\\frac{\\partial f(x, y)}{\\partial y}$$Sobel模板（Y方向）：$$G_y &#x3D;\\begin{bmatrix}1 &amp; 2 &amp; 1 \\0 &amp; 0 &amp; 0 \\-1 &amp; -2 &amp; -1 \\\\end{bmatrix}$$ 作用：\n\n检测图像中 水平边缘（例如：地平线、桌面边缘）\n强调图像中垂直方向的灰度变化\n\n代码实现\n12345678910111213clear;                % 清空工作区变量A = imread(&#x27;bot.bmp&#x27;); % 读取图像文件imshow(A);            % 显示原始图像% 水平方向Sobel算子（检测垂直边缘）h1 = [1 2 1; 0 0 0; -1 -2 -1]; % 水平方向模板B1 = imfilter(A, h1);          % 应用水平方向滤波figure; imshow(B1);            % 显示水平边缘检测结果% 垂直方向Sobel算子（检测水平边缘）h2 = [1 0 -1; 2 0 -2; 1 0 -1]; % 垂直方向模板B2 = imfilter(A, h2);          % 应用垂直方向滤波figure; imshow(B2);            % 显示垂直边缘检测结果\n\n频域滤波图像变化平缓的部分靠近频域的圆心——-&gt;低频区域\n图像中边缘、噪音、变化陡峻的部分，以放射方向离开频域的圆心—–&gt;高频区域\n\n理想滤波器低通滤波过滤边缘，噪音，变化陡峻的所在的高频分量，保留图像中变化平缓的低频分量，使图像平滑。\n理想低通滤波器（Ideal Lowpass Filter, ILPF）\n基本定义：\n理想低通滤波器（ILPF）是频域滤波器，用于仅保留低频成分（平坦区域、缓变纹理），完全截断高频成分（边缘、细节、噪声等）。\n滤波器传递函数：$$H(u, v) &#x3D;\\begin{cases}1, &amp; D(u, v) \\leq D_0 \\0, &amp; D(u, v) &gt; D_0\\end{cases}$$\n\n$H(u, v)$：滤波器在频域中对频率点 $(u, v)$ 的响应\n$D(u, v)$：该频率点到频谱中心的距离\n$D_0$：截止频率（控制保留频率的范围）\n\n 距离函数定义：$$D(u, v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}$$\n\n$M, N$：图像尺寸（频谱大小）\n$(M&#x2F;2, N&#x2F;2)$：频谱中心，即 DC 分量所在位置\n\n关键特性\n\n\n\n特性\n描述\n\n\n\n理想性\n理想低通滤波器有明确的频率截断点，没有过渡区域\n\n\n硬截断\n高频分量被完全移除，仅低于 $D_0$ 的频率通过\n\n\n振铃效应\n突变的频率截断在空间域中造成振荡现象（Gibbs 现象）\n\n\n能量集中\n保留图像大致轮廓与平滑区域，损失细节与边缘\n\n\n物理意义图示（简略）：\n\n若 $H(u,v) &#x3D; 1$：频率 $(u,v)$ 被保留\n若 $H(u,v) &#x3D; 0$：频率 $(u,v)$ 被阻断\n\n实际应用提示：\n\n优点：理论分析简单，便于理解频域滤波思想\n缺点：实际图像中常产生明显振铃（ringing）和伪影，影响视觉质量\n替代方案：高斯低通滤波器（Gaussian LPF）、巴特沃斯低通（Butterworth LPF）等，具有平滑过渡带\n\n代码实现\n123456789101112131415161718192021222324252627282930clear;                    % 清空工作区变量f = imread(&#x27;saturn_1.bmp&#x27;); % 读取图像imshow(f);                % 显示原始图像f = im2double(f);         % 转换为双精度浮点（范围[0,1]）% 傅里叶变换并中心化频谱F = fftshift(fft2(f));    % fft2计算二维DFT，fftshift将零频移至中心[M, N] = size(F);         % 获取频谱尺寸% 理想低通滤波参数D0 = 30;                  % 截止频率（半径阈值）u0 = floor(M/2);          % 频谱中心行坐标v0 = floor(N/2);          % 频谱中心列坐标% 遍历频谱，生成滤波器掩膜for u = 1:M    for v = 1:N        D = sqrt((u-u0)^2 + (v-v0)^2); % 计算(u,v)到中心的距离        if D &gt; D0            G(u,v) = 0;   % 高频部分置零        else            G(u,v) = F(u,v); % 保留低频部分        end    endend% 反变换回空间域g = ifft2(ifftshift(G));  % 逆中心化后逆傅里叶变换g = im2uint8(real(g));    % 取实部并转换为8位图像figure; imshow(g);        % 显示滤波结果\n\n高通滤波理想高通滤波器（Ideal Highpass Filter, IHPF）\n基本定义：\n理想高通滤波器通过保留频谱中的高频分量（边缘、纹理、细节），完全阻断低频分量（均匀背景、缓慢过渡区域）。其频域传递函数为：$$H(u, v) &#x3D;\\begin{cases}0, &amp; D(u, v) \\leq D_0 \\1, &amp; D(u, v) &gt; D_0\\end{cases}$$\n\n$D_0$：截止频率，决定阻断范围\n$D(u, v)$：频率点 $(u, v)$ 到频谱中心 $(M&#x2F;2, N&#x2F;2)$ 的距离\n计算公式：\n\n$$D(u, v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}$$\n 关键特性\n\n\n\n特性\n描述\n\n\n\n理想性\n完全区分高频与低频，没有过渡带\n\n\n作用\n高通：增强细节、边缘；压制平滑区域\n\n\n副作用\n高频截断太陡，空间域中易出现振铃效应（Gibbs 现象）\n\n\n物理意义：\n\n$H(u,v) &#x3D; 0$：该频率分量被阻断（平坦区域）\n$H(u,v) &#x3D; 1$：该频率分量通过（图像细节、纹理）\n\n实际应用建议替代方案：\n\n\n\n滤波器类型\n特点\n振铃效应\n场景推荐\n\n\n\n理想高通（IHPF）\n硬截断\n严重\n理论教学，分析用\n\n\n巴特沃斯高通（BHPF）\n平滑过渡\n轻微\n图像处理通用\n\n\n高斯高通（GHPF）\n无振铃，过渡自然\n无\n医学图像，高精度场景\n\n\n代码实现\n12345678910111213141516171819202122232425262728293031323334clear;                          % 清空工作区变量f = imread(&#x27;saturn_1.bmp&#x27;);     % 读取图像imshow(f);                      % 显示原始图像f = im2double(f);               % 转换为双精度浮点（范围[0,1]）% 傅里叶变换并中心化频谱F = fftshift(fft2(f));          % 计算DFT并中心化[M, N] = size(F);               % 获取频谱尺寸% 理想高通滤波参数D0 = 30;                        % 截止频率（半径阈值）u0 = floor(M/2);                % 频谱中心行坐标v0 = floor(N/2);                % 频谱中心列坐标% 初始化掩膜矩阵G = zeros(M, N);                % 初始化为全零（阻断所有）% 构建高通滤波掩膜：保留高频，去除低频for u = 1:M    for v = 1:N        D = sqrt((u - u0)^2 + (v - v0)^2);  % 到频谱中心的距离        if D &gt; D0            G(u, v) = F(u, v);  % 高频保留        else            G(u, v) = 0;        % 低频抑制        end    endend% 反变换回空间域g = ifft2(ifftshift(G));        % 逆中心化+逆傅里叶变换g = im2uint8(real(g));          % 取实部并转换为8位图像figure; imshow(g);              % 显示高通滤波后的图像\n\n巴特沃斯滤波器低通滤波12345678910111213141516171819202122232425262728clear;                    % 清空工作区变量f = imread(&#x27;saturn_1.bmp&#x27;); % 读取图像imshow(f);                % 显示原始图像f = im2double(f);         % 转换为双精度浮点（范围[0,1]）% 傅里叶变换并中心化频谱F = fftshift(fft2(f));    % fft2计算二维DFT，fftshift将零频移至中心[M, N] = size(F);         % 获取频谱尺寸% 巴特沃斯滤波器参数n = 3;                    % 滤波器阶数（控制过渡带陡峭程度）D0 = 40;                  % 截止频率（半径阈值）u0 = floor(M/2);          % 频谱中心行坐标v0 = floor(N/2);          % 频谱中心列坐标% 遍历频谱，生成巴特沃斯滤波器并应用for u = 1:M    for v = 1:N        D = sqrt((u-u0)^2 + (v-v0)^2); % 计算(u,v)到中心的距离        H = 1 / (1 + (D/D0)^(2*n));    % 巴特沃斯传递函数        G(u,v) = H * F(u,v);           % 频域滤波    endend% 反变换回空间域g = ifft2(ifftshift(G));  % 逆中心化后逆傅里叶变换g = im2uint8(real(g));    % 取实部并转换为8位图像figure; imshow(g);        % 显示滤波结果\n\n巴特沃斯低通滤波器解析（公式整理）\n传递函数\n巴特沃斯低通滤波器的频率响应函数为：$$H(u,v) &#x3D; \\frac{1}{1 + \\left( \\frac{D(u,v)}{D_0} \\right)^{2n}}$$\n\n$D(u,v)$：频率点 $(u,v)$ 到频谱中心的欧氏距离$$D(u,v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}$$\n\n$D_0$：截止频率（控制保留低频的范围）\n\n$n$：滤波器阶数（控制过渡带的陡峭程度）\n\n\n特点比较\n\n\n\n滤波器类型\n截止特性\n过渡带\n是否振铃\n应用效果\n\n\n\n理想低通\n硬截止\n无\n明显振铃\n强模糊但易产生伪影\n\n\n巴特沃斯低通\n平滑过渡\n可调（通过n）\n减少振铃\n过渡自然，常用于图像模糊\n\n\n高通滤波12345678910111213141516171819202122232425262728293031323334353637clear;                         % 清空工作区变量f = imread(&#x27;saturn_1.bmp&#x27;);    % 读取图像imshow(f); title(&#x27;原始图像&#x27;); % 显示原始图像f = im2double(f);              % 转换为双精度浮点% 傅里叶变换并中心化频谱F = fftshift(fft2(f));         [M, N] = size(F);              % 获取频谱尺寸% 巴特沃斯高通滤波器参数n = 3;                         % 阶数D0 = 20;                       % 截止频率u0 = floor(M/2);              v0 = floor(N/2);% 初始化滤波器输出矩阵G = zeros(M, N);% 遍历频谱，生成高通滤波器并应用for u = 1:M    for v = 1:N        D = sqrt((u - u0)^2 + (v - v0)^2);        if D == 0            H = 0; % 防止除以0        else            H = 1 / (1 + (D0 / D)^(2 * n));  % 巴特沃斯高通传递函数        end        G(u,v) = H * F(u,v);  % 频域滤波    endend% 反傅里叶变换回空间域g = real(ifft2(ifftshift(G)));g = im2uint8(g);              % 转换为8位图像figure; imshow(g); title(&#x27;巴特沃斯高通滤波结果 (D0 = 20, n = 3)&#x27;);\n\n巴特沃斯高通滤波器（Butterworth Highpass Filter, BHPF）\n传递函数\n对于图像频域中每个频率点 $(u,v)$，其传递函数为：$$H(u,v) &#x3D; \\frac{1}{1 + \\left(\\frac{D_0}{D(u,v)}\\right)^{2n}} &#x3D; 1 - \\frac{1}{1 + \\left(\\frac{D(u,v)}{D_0}\\right)^{2n}}$$其中：\n\n$D(u,v) &#x3D; \\sqrt{(u - M&#x2F;2)^2 + (v - N&#x2F;2)^2}$：频率点 $(u,v)$ 到频谱中心的欧氏距离；\n$D_0$：截止频率，控制滤波器的阻断范围；\n$n$：阶数，控制滤波器过渡带的陡峭程度；\n$H(u,v)$：传递函数值（频率响应），表示该频率是否通过。\n\n特点比较\n\n\n\n滤波器类型\n传递函数形状\n振铃效应\n控制参数\n应用场景\n\n\n\n理想高通（IHPF）\n二值阶跃函数（硬截断）\n严重\n截止频率 $D_0$\n教学、理论分析\n\n\n巴特沃斯高通（BHPF）\n平滑过渡（可调阶数）\n较轻微\n$D_0$、阶数 $n$\n通用图像锐化、纹理增强\n\n\n高斯高通（GHPF）\n指数平滑衰减函数\n无\n截止频率 $D_0$\n医学图像、工业检测\n\n\n彩色图像增强伪彩色图像增强将一幅灰度图转换成一幅彩色图像\n简单处理：\n将灰度值分为两个区间\n实例\n灰度范围$[0-127]$赋予蓝色$[0,0,255]$\n灰度范围$[128-255]$赋予红色$[255,0,0]$\n代码实现\n1234567891011121314151617clear;                    % 清空工作区变量X = imread(&#x27;cat.bmp&#x27;);    % 读取图像（注：原图为彩色，但代码按灰度处理）imshow(X);                % 显示原始图像[M, N] = size(X);         % 获取图像尺寸（仅获取前两维，可能存在问题）% 遍历每个像素，根据灰度值分配颜色for i = 1:M    for j = 1:N        if X(i, j) &lt; 128            Y(i, j, 1:3) = [0 0 255];  % 蓝色（低灰度）        else            Y(i, j, 1:3) = [255 0 0];   % 红色（高灰度）        end    endendfigure; imshow(Y);        % 显示处理后的图像\n\n推广处理：\n把灰度值分割成多个区间\n热金属编码灰度范围$[1-63]$赋予蓝色$[0,0,255]$\n灰度范围$[64-127]$赋予紫色$[200,0,200]$\n灰度范围$[128-191]$赋予桔黄色$[255,150,0]$\n灰度范围$[192-254]$赋予黄色$[255,255,0]$\n代码实现\n12345678910111213141516171819202122clear;X = imread(&#x27;cat.bmp&#x27;);  % 读取图像（假设为灰度图）imshow(X);              % 显示原始图像Y = X / 64;            % 量化：将像素值压缩到0~3范围（256/64=4级）[M,N] = size(Y);       % 获取图像尺寸for i = 1:M    for j = 1:N        switch Y(i,j)   % 根据量化值分配颜色            case 0                Y1(i,j,1:3) = [0 0 255];     % 蓝色            case 1                Y1(i,j,1:3) = [200 0 200];   % 紫色            case 2                Y1(i,j,1:3) = [255 150 0];   % 橙色            case 3                Y1(i,j,:) = [255 255 0]; % 补充黄色        end    endend% 注：代码未显示Y1的显示部分（应有 imshow(Y1)）\n\n彩虹编码灰度范围$[0-63]$赋予蓝色$[0,0,255]$\n灰度范围$[64-127]$赋予绿色$[0,255,0]$\n灰度范围$[128-191]$赋予红色$[255,0,0]$\n灰度范围$[192-254]$赋予品红色$[255,0,255]$\n代码实现\n1234567891011121314151617181920212223242526272829clear;X = imread(&#x27;cat.bmp&#x27;);    % 读取灰度图像imshow(X); title(&#x27;原始图像&#x27;);% Step 1: 灰度值量化为 0~3（分为4段）Y = floor(double(X) / 64);     % 将像素值分段：0=[0,63], 1=[64,127], etc.Y(Y == 4) = 3;                 % 处理255时 floor(255/64)=3.984→4，强制归入第4类[M, N] = size(Y);Y1 = zeros(M, N, 3, &#x27;uint8&#x27;);  % 初始化RGB图像% Step 2: 色彩映射for i = 1:M    for j = 1:N        switch Y(i,j)            case 0                Y1(i,j,:) = [0, 0, 255];     % 蓝色：0–63            case 1                Y1(i,j,:) = [0, 255, 0];     % 绿色：64–127            case 2                Y1(i,j,:) = [255, 0, 0];     % 红色：128–191            case 3                Y1(i,j,:) = [255, 0, 255];   % 品红色：192–254（含255）        end    endend% Step 3: 显示伪彩色图像figure; imshow(Y1); title(&#x27;伪彩色映射图像&#x27;);\n\n假彩色图像增强将同一幅灰度图送入红、绿、蓝三个变换器，在三个变换器中对同一灰度实施不同变化，使三个变换器输出不同。将三个不同输出合成某一种彩色图像。\n变换器算法的线性方程\n红色通道 $R$$$R(f) &#x3D;\\begin{cases}0, &amp; 0 \\le f &lt; \\dfrac{L}{2} \\4f - 2L, &amp; \\dfrac{L}{2} \\le f &lt; \\dfrac{3L}{4} \\L, &amp; \\dfrac{3L}{4} \\le f \\le L\\end{cases}$$绿色通道 $G$$$G(f) &#x3D;\\begin{cases}4f, &amp; 0 \\le f &lt; \\dfrac{L}{4} \\L, &amp; \\dfrac{L}{4} \\le f &lt; \\dfrac{3L}{4} \\-4f + 4L, &amp; \\dfrac{3L}{4} \\le f \\le L\\end{cases}$$蓝色通道 $B$$$B(f) &#x3D;\\begin{cases}L, &amp; 0 \\le f &lt; \\dfrac{L}{4} \\-4f + 2L, &amp; \\dfrac{L}{4} \\le f &lt; \\dfrac{L}{2} \\0, &amp; \\dfrac{L}{2} \\le f \\le L\\end{cases}$$代码实现\n1234567891011121314151617181920212223242526272829clearf = imread(&#x27;rice.bmp&#x27;);  % 读取图像（应为灰度图）imshow(f);[M,N] = size(f); L = 255;f = double(f);           % 转换为双精度f1 = floor(f/64);        % 4级量化（0-3）% 初始化RGB通道R = f1; G = f1; B = f1;  % 错误：应用zeros(M,N)初始化（ppt代码）R = zeros(M,N); G = zeros(M,N); B = zeros(M,N); % 正确初始化for i = 1:M    for j = 1:N        switch f1(i,j)   % 根据量化值分配颜色            case 0                R(i,j)=0; G(i,j)=4*f(i,j); B(i,j)=L;            case 1                R(i,j)=0; G(i,j)=L; B(i,j)=-4*f(i,j)+2*L;             case 2                R(i,j)=4*f(i,j)-2*L; G(i,j)=L; B(i,j)=0;            case 3                R(i,j)=L; G(i,j)=-4*f(i,j)+4*L; B(i,j)=0;        end    endendg(:,:,1) = R; g(:,:,2) = G; g(:,:,3) = B; % 合并通道g = uint8(g);figure, imshow(g);\n\n真彩色图像增强将真彩色图像RGB分开，针对各分量分别进行增强处理，然后合并为新的真彩色图像。\n六图像压缩和冗余压缩类型：有损、无损\n冗余类型：像素冗余、编码冗余、视觉心理冗余\n像素冗余—-&gt;压缩方法：行程编码（无损，可逆）\n实例\n0….0（15个）2….2（11个）1….1（30个）4….4（70个）0….0（18个）\n行程编码：\n15{0}11{2}30{1}70{4}18{0}\n编码冗余—-&gt;哈夫曼编码（可逆）\n视觉心理冗余—–&gt;（有损，不可逆）\n图像编码解码过程：\n原始图像—-&gt;压缩编码器—–&gt;编码结果——&gt;存储&#x2F;传输——&gt;压缩解码器—-&gt;解码图像\n注：解码图像与原始图像相同（无损压缩）&#x2F;不相同（有损压缩）\n压缩编码器模型（3个独立操作）：\n输入原始图像—&gt;映射器—-&gt;量化器—-&gt;符号编码器—-&gt;生成编码\n映射器：减少像素冗余，使用行程编码（无损）\n量化器：减少视觉心理冗余（仅用于有损压缩）\n符号编码器：减少编码冗余，使用哈夫曼编码（无损）\n压缩解码器模型（2个独立操作）：\n输入编码—&gt;反符号解码器—–&gt;反映射器—–&gt;输出解码图像\n注：整个过程与编码模型相反，由于量化是不可逆操作，所以没有“反量化器”\n行程编码行程编码（Run-Length Encoding, RLE）是一种无损压缩方法，适用于重复值较多的图像（如黑白图、二值图或简单灰度图）。下面是它的压缩前与压缩后大小的计算方法详解：\n 一、压缩前大小（未压缩图像）\n压缩前的数据通常是图像的原始像素值，每个像素占用固定的字节。\n计算公式：$$\\text{未压缩大小（字节）} &#x3D; \\text{图像总像素数} \\times \\text{每像素字节数}$$说明：\n\n对于 8位灰度图，每个像素占 1字节（8bits）；\n若是 RGB 彩色图像，每个像素占 3字节（24bits）（R, G, B 各1字节）；\n图像总像素数 &#x3D; 行数 × 列数\n\n二、压缩后大小（RLE）\n行程编码将连续相同的像素值用“值 + 次数”对来表示，因此压缩后只记录：$$\\text{压缩后数据} &#x3D; \\sum_{i&#x3D;1}^{k} \\left(\\text{像素值} + \\text{重复次数}\\right)$$其中，$k$ 是图像中不同的连续值段数。\n计算公式：$$\\text{压缩后大小（字节）} &#x3D; k \\times (\\text{每个值的字节数} + \\text{每个次数的字节数})$$\n\n\n\n\n\n\n\n\n\n通常，每个像素值和重复次数都用 1 字节 表示（即 8 位图像中）\n注意：1个字节8bit\n实例（这里是按bit算的）\n压缩前：$aaaabbbccdeeeeefffffff$\n$22*8&#x3D;176bits$\n压缩后：$4a3b2c1d5e7f$\n$6*（3+8）&#x3D;66bits$\n代码实现（压缩部分）\n12345678910111213141516171819202122232425262728clear all;I1 = imread(&#x27;lena.bmp&#x27;);       % 读取图像I2 = im2bw(I1, 0.5);          % 二值化（阈值0.5）I3 = I2(:);                   % 将图像展开为一维列向量I3len = length(I3);           % 获取原始数据长度% 游程编码核心算法j = 1; n = 1;                 % j: 游程序号，n: 当前游程长度for z = 1:(I3len-1)    if I3(z) == I3(z+1)       % 当前像素与下一像素相同        n = n + 1;            % 游程长度+1    else        pixel(j) = I3(z);     % 记录当前游程的像素值（0或1）        numpixel(j) = n;      % 记录当前游程长度        j = j + 1;            % 移动到下一个游程        n = 1;                % 重置游程长度计数器    endend% 处理最后一个游程pixel(j) = I3(z+1);           % 记录最后一个像素值numpixel(j) = n;              % 记录最后一个游程长度% 计算压缩比和输出结果pixel_len = length(pixel);    % 压缩后的游程总数CR = I3len / (pixel_len * 2); % 压缩比公式（注：分母为游程对数量×2）disp(&#x27;压缩比：&#x27;); disp(CR);disp(&#x27;原图像数据的长度：&#x27;); disp(I3len);disp(&#x27;压缩后图像数据的长度：&#x27;); disp(pixel_len);\n\n哈夫曼编码哈夫曼编码基本步骤\n\n统计字符频率\n\n构建哈夫曼树\n\n把每个字符看作一个“节点”，频率作为“权值”。\n每次从节点集中选两个最小的，合并成一个新的父节点，其权值为两个子节点权值之和。\n重复这个过程，直到只剩一个节点（根节点）。\n\n\n\n12345678初始：a(3), b(2), c(1)合并最小两个：b(2) + c(1) → 新节点bc(3)剩下：a(3), bc(3)再合并：a(3) + bc(3) → 根节点abc(6)\n\n123456   abc(6)  /     \\a(3)   bc(3)      /    \\    c(1)   b(2)\n\n\n\n\n\n\n\n\n\n\n哈夫曼编码中，将较大频率放左边还是右边，其实没有影响最终的压缩效率，但会影响具体的编码结果（0 和 1 的分配）。\n占用空间的计算\n每个字符：\n\n\n\n\n\n\n\n\n\n1字符频率 × 它的码长（单位：位）\n总压缩后大小（单位：位）：\n\n1∑（每个字符的频率 × 对应码长）\n实例\n字符串 &quot;aaaabbbccd&quot;\n统计频率：\n1234a: 4b: 3c: 2d: 1\n\n构建哈夫曼树（略），得到编码可能如下：\n1234a: 0     （频率高 → 路径短）b: 10c: 110d: 111\n\n对应的码长：\n1234a: 1 位b: 2 位c: 3 位d: 3 位\n\n\n\n\n字符\n频率\n码长\n占用位数\n\n\n\na\n4\n1\n4\n\n\nb\n3\n2\n6\n\n\nc\n2\n3\n6\n\n\nd\n1\n3\n3\n\n\n总计\n\n\n19 位\n\n\n原始数据有 10 个字符，若是定长编码（每个字符都用 8 bit 存储）：\n\n原始大小 &#x3D; 10 × 8 = 80 位\n七膨胀膨胀（Dilation）是图像形态学处理中常用的一种操作，主要用于扩展图像中目标（前景）区域的边界，让物体“变大”。\n一、基本概念\n\n输入：二值图像（通常是0表示背景，1表示前景）\n工具：结构元素（SE），比如一个小的方形、圆形、十字形模板\n目的：将结构元素“套”在图像上，检查是否与前景接触，决定是否扩展\n\n 二、膨胀的定义（数学）\n设图像为集合 $A$，结构元素为 $B$，则膨胀定义为：$$A \\oplus B &#x3D; { z \\mid (\\hat{B})_z \\cap A \\neq \\emptyset }$$直观理解：\n\n将结构元素的“中心”移动到每个前景像素位置\n把结构元素覆盖到图像中，把结构元素所有接触的像素设为前景\n\n 三、直观理解\n**前景是白色（1），背景是黑色（0）**时：\n\n\n\n\n\n\n\n\n\n若某点周围有一个前景像素，结构元素就会把它扩展成一片前景。\n所以：\n\n前景边缘会向外“膨胀”\n小黑洞、裂缝会被填补\n\n腐蚀腐蚀运算（Erosion）是图像形态学中的一种基本操作，常用于去除小的白色区域、分离连接物体、缩小图像中前景区域（通常是白色）的边界。\n 一、基本概念\n腐蚀可以理解为：\n\n\n\n\n\n\n\n\n\n用结构元素去“试探”图像中每一个位置，只有当结构元素“完全贴合”目标区域（即前景）时，该位置才保留为前景。否则，就腐蚀成背景。\n二、形式定义\n设：\n\n原始图像为 $A$（通常是二值图像）\n结构元素为 $B$\n\n腐蚀运算记作：$$A \\ominus B$$数学定义是：\n\n\n\n\n\n\n\n\n\n腐蚀后图像中，所有点 $z$ 满足结构元素 $B$ 平移到 $z$ 后，仍完全包含于原图像 $A$。\n三、操作直觉\n\n把结构元素中心对齐到图像中每一个前景点。\n如果结构元素完全落在图像的白色区域内（前景），则中心点保留为白色。\n否则，中心点变为黑色（背景）。\n\n四、腐蚀的效果\n\n\n\n原图前景\n腐蚀后效果\n\n\n\n白色区域\n被收缩、变小、变细\n\n\n小的白点\n可能被完全腐蚀掉\n\n\n空洞边界\n会向内收缩，缩小孔洞\n\n\n开运算开运算（Opening）是图像形态学中的一种复合操作，表示为：$$A \\circ B &#x3D; (A \\ominus B) \\oplus B$$其中：\n\n$A$：原始图像（二值图）\n$B$：结构元素\n$\\ominus$：腐蚀运算\n$\\oplus$：膨胀运算\n\n什么是开运算\n开运算 &#x3D; 先腐蚀，后膨胀\n\n\n\n\n\n\n\n\n\n其本质是：去除小的前景区域（白色区域）或细小突出部分，同时保留整体轮廓形状不变的大物体。\n操作直觉\n\n腐蚀：去掉图像边缘、小的前景点、细小突出。\n膨胀：恢复腐蚀后被缩小的主要结构。\n\n这样，小噪点不会恢复，而大结构会恢复原形，所以开运算非常适合去除小物体和突出部分。\n开运算的效果\n\n\n\n作用\n效果\n\n\n\n去除小白点\n噪声被腐蚀掉，无法恢复\n\n\n平滑前景物体边界\n去除尖角、毛刺\n\n\n分离粘连物体\n若连接细小部分被腐蚀，则被断开\n\n\n不改变主前景结构\n大物体轮廓基本保留\n\n\n闭运算闭运算（Closing）是形态学图像处理中的一种基本操作，它是膨胀后腐蚀的复合操作，记作：$$A \\bullet B &#x3D; (A \\oplus B) \\ominus B$$其中：\n\n$A$：原始图像（二值图像，白色代表前景）\n$B$：结构元素（通常为小圆、方块、线段等）\n$\\oplus$：膨胀\n$\\ominus$：腐蚀\n\n 闭运算做了什么\n\n\n\n\n\n\n\n\n\n闭运算 &#x3D; 先膨胀，再腐蚀\n它的目标是：\n  填补前景中的小孔洞、缝隙  连接相近但断裂的白色区域（前景）  平滑物体边界，去除黑色小凹陷\n 操作流程解释\n\n膨胀：前景区域变大，填补小洞、连接细缝。\n腐蚀：把膨胀带来的外扩减掉，只保留原本连接和填补的部分。\n\n闭运算的作用总结\n\n\n\n功能\n效果\n\n\n\n填小黑洞\n内部的小黑洞会被填满\n\n\n连接细线断裂\n若两白色区域之间缝隙小，能连起来\n\n\n平滑边缘\n去除凹陷区域\n\n\n保留整体形状\n不会大范围改变图像结构\n\n\n对比\n\n\n运算类型\n对二值图作用（前景为白）\n对灰度图作用\n\n\n\n腐蚀\n收缩白色区域，去除小白点，细线消失\n凹陷更明显，整体暗化，边缘细节变清晰\n\n\n膨胀\n扩张白色区域，连接断裂，填补细缝、孔洞\n凸起更明显，整体变亮，模糊小凹陷\n\n\n开运算\n先腐蚀后膨胀，去除小白噪声，断开细白线\n平滑亮区域边缘，去除小高亮区（如亮斑、噪声）\n\n\n闭运算\n先膨胀后腐蚀，填补小黑洞，连接接近白区域\n平滑暗区域边缘，填暗斑，连接中断结构\n\n\n八边缘检测正交梯度算子法基本概念\n正交梯度算子法是一种典型的边缘检测方法，属于基于一阶导数的图像处理技术。\n\n它通过计算图像在水平方向和垂直方向的灰度变化（即梯度）来检测边缘。\n在边缘处，图像灰度变化剧烈，梯度幅值较大，因此可以通过梯度检测边缘。\n\n数学定义\n(1) 梯度向量定义：\n给定图像灰度函数 $f(x, y)$，其梯度为：$$\\nabla f(x, y) &#x3D;\\begin{bmatrix}G_x \\G_y\\end{bmatrix}\\begin{bmatrix}\\frac{\\partial f}{\\partial x} \\\\frac{\\partial f}{\\partial y}\\end{bmatrix}$$\n\n$G_x$：沿水平方向的灰度变化（横向变化率）\n$G_y$：沿垂直方向的灰度变化（纵向变化率）\n\n(2) 梯度幅值（Gradient Magnitude）：$$G(x, y) &#x3D; \\sqrt{G_x^2 + G_y^2}$$\n\n\n\n\n\n\n\n\n\n表示像素处灰度变化的“强度”，即边缘显著程度。\n(3) 梯度方向（Gradient Direction）：$$\\varphi(x, y) &#x3D; \\arctan\\left(\\frac{G_y}{G_x}\\right)$$\n\n\n\n\n\n\n\n\n\n表示灰度变化的“方向”，与边缘方向垂直。\n一阶差分近似梯度法在数字图像处理中，图像是离散的像素点组成的，无法直接使用连续导数公式。 因此，用一阶差分（finite difference）近似导数，来表示图像中灰度值的变化。\n这种差分可以反映图像中像素灰度变化的程度——即边缘检测的核心依据。\n定义\n设图像为二维离散函数 $f(m,n)$，其中：\n\n$m$：图像的行（垂直方向）\n$n$：图像的列（水平方向）\n\n水平方向梯度：$$G_h(m,n) &#x3D; f(m,n) - f(m,n-1)$$表示当前像素与其左邻像素的灰度差，反映水平方向的灰度变化。\n垂直方向梯度：$$G_v(m,n) &#x3D; f(m,n) - f(m-1,n)$$表示当前像素与其上邻像素的灰度差，反映垂直方向的灰度变化。\n差分可以通过卷积操作来实现，用于图像的快速处理。\n水平方向模板 $W_h$：$$W_h &#x3D;\\begin{bmatrix}0 &amp; 0 &amp; 0 \\-1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0\\end{bmatrix}$$\n\n相当于对当前像素与其左边像素做差。\n核心位于中间行中：$-1, 1$\n\n垂直方向模板 $W_v$：$$W_v &#x3D;\\begin{bmatrix}0 &amp; -1 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0\\end{bmatrix}$$\n\n相当于对当前像素与其上方像素做差。\n核心位于中间列中：$-1, 1$\n\n设输入图像为 $f$，则有：\n\n水平梯度图像：$$G_h &#x3D; f * W_h$$\n\n垂直梯度图像：$$G_v &#x3D; f * W_v$$\n\n\n其中 $*$ 表示卷积操作。\n算子总结\n\n\n类型\n名称\n卷积模板\n描述方向\n\n\n\n1\n正交算子（水平&#x2F;垂直）\n1001\n垂直方向\n\n\n2\nRoberts 算子\n对角\n45°&#x2F;135°方向\n\n\n3\n斜着的 1001\n斜方向\n类似 Roberts，更简化版\n\n\n4\nSobel 算子\n水平&#x2F;垂直\n考虑邻域加权\n\n\n5\nPrewitt 算子\n水平&#x2F;垂直\n类似 Sobel，但不加权\n\n\n正交梯度算子（差分版 1001）水平方向（检测上下边缘）：\n123Wx = [ 0  1  0       0 -1  0       0  0  0 ];\n\n垂直方向（检测左右边缘）：\n123Wy = [ 0  0  0       1 -1  0       0  0  0 ];\n\n等价于对图像进行一阶差分，称为正交方向差分模板（Orthogonal Difference）。\nRoberts 算子（经典对角线边缘）方向1（45°）：\n12R1 = [ -1  0        0  1 ];\n\n方向2（135°）：\n12R2 = [ 0 -1       1  0 ];\n\n\n尺寸：2×2\n用于检测图像的对角线方向边缘\n响应快但对噪声更敏感\n\nSobel 算子（常用，带加权）水平方向（x方向）：\n123Sx = [ -1  0  1       -2  0  2       -1  0  1 ];\n\n垂直方向（y方向）：\n123Sy = [ -1 -2 -1        0  0  0        1  2  1 ];\n\n\n中心像素权重更高（加权）\n对噪声有一定抑制能力\n常用于梯度边缘检测中计算 Gx 和 Gy\n\nPrewitt 算子（与 Sobel 类似，但不加权）水平方向（x方向）：\n123Px = [ -1  0  1       -1  0  1       -1  0  1 ];\n\n垂直方向（y方向）：\n123Py = [ -1 -1 -1        0  0  0        1  1  1 ];\n\n\n类似 Sobel，但每列权重一致\n更简单，但边缘检测效果略弱于 Sobel\n\n梯度图像 一、梯度图像计算三种方式与对应“距离度量”\n\n\n\n梯度幅度计算公式\n数学表达\n对应距离度量\n特点\n\n\n\n欧氏距离\n$G(m,n) &#x3D; \\sqrt{G_h^2 + G_v^2}$\n$D_e$\n精度高、边缘平滑，但计算慢（含平方根）\n\n\n城市街区距离\n$G(m,n)&#x3D;∥Gh∥+∥Gv∥$\n$D_4$\n计算简单，适合实时处理\n\n\n棋盘距离\n$G(m,n)&#x3D;max(∣Gh∣,∣Gv∣)$\n$D_8$\n对噪声敏感，边缘较粗\n\n\n 二、三种“距离度量”的几何理解\n\n\n\n距离类型\n数学定义\n直观含义\n\n\n\n欧氏距离 $D_e$\n$\\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$\n直线距离（最精确）\n\n\n城市街区距离 $D_4$\n$∥x2−x1∥+∥y2−y1∥$\n只能横向或纵向移动（如棋盘车）\n\n\n棋盘距离 $D_8$\n$max(∣x2−x1∣,∣y2−y1∣)$\n可横向、纵向或斜向移动（如棋盘王）\n\n\n三、应用建议总结（记忆口诀）\n\n\n\n场景\n推荐方法\n记忆口诀\n\n\n\n医疗分析、高精度检测\n欧氏距离（公式1）\n要精细，用“欧”\n\n\n实时嵌入式、快速响应\n城市街区（公式2）\n要快速，选“街”\n\n\n初步筛选、容忍粗糙边缘\n棋盘距离（公式3）\n快粗糙，用“棋”\n\n\n方向梯度法Prewitt算子\n\n\n方向\n名称\n模板 $W_i$\n\n\n\n东\n$W_0$\n$\\begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\end{bmatrix}$\n\n\n东北\n$W_1$\n$\\begin{bmatrix} 0 &amp; 1 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; -1 &amp; 0 \\end{bmatrix}$\n\n\n北\n$W_2$\n$\\begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ -1 &amp; -1 &amp; -1 \\end{bmatrix}$\n\n\n西北\n$W_3$\n$\\begin{bmatrix} 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; -1 \\ 0 &amp; -1 &amp; -1 \\end{bmatrix}$\n\n\n西\n$W_4$\n$\\begin{bmatrix} 1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\end{bmatrix}$\n\n\n西南\n$W_5$\n$\\begin{bmatrix} 0 &amp; -1 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\ 1 &amp; 1 &amp; 0 \\end{bmatrix}$\n\n\n南\n$W_6$\n$\\begin{bmatrix} -1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 \\end{bmatrix}$\n\n\n东南\n$W_7$\n$\\begin{bmatrix} -1 &amp; -1 &amp; 0 \\ -1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\end{bmatrix}$\n\n\n使用方式：\n对于每个像素 $(m,n)$，分别将图像的 3×3 邻域与这 8 个模板进行卷积，得到 8 个响应值 $R_i(m,n)$，再选取最大值作为最终边缘响应：$$G(m,n) &#x3D; \\max_i R_i(m,n)$$\nKirsch算子\n\n\n方向\n名称\n模板 $W_i$\n检测边缘方向\n\n\n\n东\n$W_0$\n$\\begin{bmatrix} -3 &amp; -3 &amp; 5 \\ -3 &amp; 0 &amp; 5 \\ -3 &amp; -3 &amp; 5 \\end{bmatrix}$\n垂直边缘（东-西）\n\n\n东北\n$W_1$\n$\\begin{bmatrix} -3 &amp; 5 &amp; 5 \\ -3 &amp; 0 &amp; 5 \\ -3 &amp; -3 &amp; -3 \\end{bmatrix}$\n西北-东南对角线\n\n\n北\n$W_2$\n$\\begin{bmatrix} 5 &amp; 5 &amp; 5 \\ -3 &amp; 0 &amp; -3 \\ -3 &amp; -3 &amp; -3 \\end{bmatrix}$\n水平边缘（北-南）\n\n\n西北\n$W_3$\n$\\begin{bmatrix} 5 &amp; 5 &amp; -3 \\ 5 &amp; 0 &amp; -3 \\ -3 &amp; -3 &amp; -3 \\end{bmatrix}$\n东北-西南对角线\n\n\n西\n$W_4$\n$\\begin{bmatrix} 5 &amp; -3 &amp; -3 \\ 5 &amp; 0 &amp; -3 \\ 5 &amp; -3 &amp; -3 \\end{bmatrix}$\n垂直边缘（西-东）\n\n\n西南\n$W_5$\n$\\begin{bmatrix} -3 &amp; -3 &amp; -3 \\ 5 &amp; 0 &amp; -3 \\ 5 &amp; 5 &amp; -3 \\end{bmatrix}$\n东南-西北对角线\n\n\n南\n$W_6$\n$\\begin{bmatrix} -3 &amp; -3 &amp; -3 \\ -3 &amp; 0 &amp; -3 \\ 5 &amp; 5 &amp; 5 \\end{bmatrix}$\n水平边缘（南-北）\n\n\n东南\n$W_7$\n$\\begin{bmatrix} -3 &amp; -3 &amp; -3 \\ -3 &amp; 0 &amp; 5 \\ -3 &amp; 5 &amp; 5 \\end{bmatrix}$\n西南-东北对角线\n\n\n计算步骤\n步骤一：对图像每个像素，用 8 个 Kirsch 模板分别进行卷积（即计算邻域与模板的乘积和）：$$R_i(m,n) &#x3D; f(m,n) * W_i \\quad (i &#x3D; 0 \\sim 7)$$步骤二：在这 8 个响应中选择最大值作为最终的边缘强度：$$G(m,n) &#x3D; \\max_i R_i(m,n)$$\n二阶导数算子法拉普拉斯算子定义为：$$\\nabla^2 f &#x3D; \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2}$$常用模板一（4邻域）：$$L &#x3D; \\begin{bmatrix}0 &amp; 1 &amp; 0 \\1 &amp; -4 &amp; 1 \\0 &amp; 1 &amp; 0\\end{bmatrix}$$常用模板二（8邻域）：$$L &#x3D; \\begin{bmatrix}1 &amp; 1 &amp; 1 \\1 &amp; -8 &amp; 1 \\1 &amp; 1 &amp; 1\\end{bmatrix}$$模板特点说明：\n\n\n\n模板类型\n名称\n邻域类型\n特点\n\n\n\n模板一\n4邻域拉普拉斯\n十字形\n计算量小，响应清晰\n\n\n模板二\n8邻域拉普拉斯\n十字 + 对角线\n响应更强，适用于更复杂的边缘结构\n\n\n\n\n\n优点\n缺点\n\n\n\n不依赖方向，检测速度快\n对噪声极为敏感\n\n\n可检测所有方向的边缘\n边缘位置不如一阶导数精确\n\n\nLOG算子LoG 算子是将 高斯滤波器（Gaussian） 与 拉普拉斯算子（Laplacian） 相结合的边缘检测方法，用于先平滑图像，再检测边缘，从而 降低拉普拉斯算子对噪声的敏感性。\n其核心思想是：\n\n\n\n\n\n\n\n\n\n先对图像进行高斯模糊（降噪），再使用拉普拉斯算子检测边缘。\n 离散模板（示例）\n常用的是对标准二维高斯函数的拉普拉斯求导，生成 离散卷积模板。一个常见的 5×5 离散 LoG 模板如下：\n（σ ≈ 1.4）$$\\text{LoG} &#x3D; \\begin{bmatrix}0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; -2 &amp; -1 &amp; 0 \\-1 &amp; -2 &amp; 16 &amp; -2 &amp; -1 \\0 &amp; -1 &amp; -2 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; -1 &amp; 0 &amp; 0\\end{bmatrix}$$\n\n中心正值，周围为负值或0\n和为0（因为平滑之后再检测边缘）\n\n各类算子特点平滑模版：\n\n模版内系数全正\n模版内系数和为1\n\n锐化模版\n\n系数有正有负，表示差分运算\n模版内系数和为1\n\n边缘检测模版\n\n系数有正有负，表示差分运算\n模版内系数和为0\n\n阈值分割极小值阈值分割123456789101112131415161718192021222324clear;G0 = imread(&#x27;rabbit.jpg&#x27;);      % 读取彩色图像G = rgb2gray(G0);              % 转换为灰度图imshow(G);                     % 显示原图figure; imhist(G);             % 显示灰度直方图% 计算直方图差分[h, x] = imhist(G);            % h: 直方图频数, x: 灰度级(0-255)df1 = diff(h);                 % 一阶差分（直方图斜率）df2 = diff(df1);               % 二阶差分（曲率变化）[m, n] = size(df2);T = 0;                         % 初始化阈值% 自动阈值选择：寻找直方图的&quot;谷底&quot;for i = 1:m    if (abs(df1(i+1)) &lt;= 0.001 &amp;&amp; df2(i) &gt; 0)  % 条件：斜率接近0且曲率凸起        T = x(i+2);            % 确定阈值        break;    endendG_bw = im2bw(G, T/255);        % 二值化（阈值归一化到[0,1]）figure; imshow(G_bw);          % 显示二值结果\n\n迭代阈值1234567891011121314151617181920212223242526272829303132333435363738394041clear;A = imread(&#x27;tree.bmp&#x27;);  imshow(A);  % 读取并显示原图h = imhist(A);                       % 计算灰度直方图% 初始化阈值t = [];  t(1) = (min(A(:)) + max(A(:))) / 2;  % 初始阈值=灰度范围中点MAX = 500;  L = 256;                 % 最大迭代次数/灰度级数for i = 1:MAX    % 计算低灰度类（背景）的灰度总和(s1)和像素数(s2)    s1 = 0; s2 = 0;    for k = 1:t(i)        s1 = s1 + h(k) * k;          % 加权灰度求和        s2 = s2 + h(k);              % 像素数量求和    end    zb = s1 / s2;                    % 背景平均灰度    % 计算高灰度类（前景）的灰度总和(s3)和像素数(s4)    s3 = 0; s4 = 0;    for k = t(i)+1:L        s3 = s3 + h(k) * k;        s4 = s4 + h(k);    end    zo = s3 / s4;                    % 前景平均灰度    % 更新阈值    t(i+1) = floor((zb + zo) / 2);    % 终止条件：阈值变化小于1    if abs(t(i+1) - t(i)) &lt; 1        break;    endend% 应用最终阈值tt进行二值化tt = t(i+1);B = A;B(B &lt; tt) = 0;      % 低于阈值设为0（黑）B(B &gt;= tt) = 255;   % 高于阈值设为255（白）figure; imshow(B);  % 显示结果\n\n区域生长基本步骤（简单区域生长）\n\n选定种子点（如坐标 $(m_0, n_0)$，灰度为 $f_0$）\n设定阈值 $T$（灰度相似性准则）\n将与种子点相邻的像素中，灰度值与 $f_0$ 差值 &lt; $T$ 的像素并入区域\n将新加入的像素当作种子，继续扩展\n直到没有新像素满足准则为止\n\n\n九链码表达\n差分码（后一位减前一位）\n\n注：差分码有旋转不变性\n形状数\n\n形状数 &#x3D; 差分码的循环排列中最小的一个数\n它是一种旋转不变表示：即相同的边界轮廓，即使旋转后，形状数也不变。\n也叫最小表示（Minimum Representation）\n\n实例\n\n\n\n\n\n\n\n\n\n差分码是：33133030要求形状数\n步骤：找出差分码的所有循环排列，取字典序最小者\n所有循环排列（从不同位置开始）：\n\n33133030\n31330303\n13303033\n33030331\n30303313\n03033133 ✅\n30331330\n03313303\n\n其中字典序（按从左到右大小）最小的是：\n→ 03033133\n这就是形状数。\n目标的四叉树、二叉树表达四叉树\n\n二叉树\n\nn级完全四叉树的结点总数公式\n设：\n\n根节点为第 0 层；\n四叉树总共有 n+1 层（从 0 到 n）；\n每层是完全展开的（即每个非叶节点都有 4 个子节点）；\n\n那么第 k 层的结点数为：$$4^k$$总结点数 N：$$N &#x3D; \\sum_{k&#x3D;0}^{n} 4^k &#x3D; 4^0 + 4^1 + 4^2 + \\cdots + 4^n$$这是一个等比数列求和，公比为 4：$$N &#x3D; \\frac{4^{n+1} - 1}{4 - 1} &#x3D; \\frac{4^{n+1} - 1}{3}$$\n目标骨架表达中轴变换方法\n\n\n","slug":"考点复习","date":"2025-06-10T16:13:46.000Z","categories_index":"","tags_index":"数字图像处理","author_index":"yona-lia"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2025-06-10T13:34:40.545Z","categories_index":"","tags_index":"","author_index":"yona-lia"}]